// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package Saml

import (
	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

type IdentityProvider struct {
	s *pulumi.ResourceState
}

// NewIdentityProvider registers a new resource with the given unique name, arguments, and options.
func NewIdentityProvider(ctx *pulumi.Context,
	name string, args *IdentityProviderArgs, opts ...pulumi.ResourceOpt) (*IdentityProvider, error) {
	if args == nil || args.Alias == nil {
		return nil, errors.New("missing required argument 'Alias'")
	}
	if args == nil || args.Realm == nil {
		return nil, errors.New("missing required argument 'Realm'")
	}
	if args == nil || args.SingleSignOnServiceUrl == nil {
		return nil, errors.New("missing required argument 'SingleSignOnServiceUrl'")
	}
	inputs := make(map[string]interface{})
	if args == nil {
		inputs["addReadTokenRoleOnCreate"] = nil
		inputs["alias"] = nil
		inputs["authenticateByDefault"] = nil
		inputs["backchannelSupported"] = nil
		inputs["displayName"] = nil
		inputs["enabled"] = nil
		inputs["firstBrokerLoginFlowAlias"] = nil
		inputs["forceAuthn"] = nil
		inputs["hideOnLoginPage"] = nil
		inputs["linkOnly"] = nil
		inputs["nameIdPolicyFormat"] = nil
		inputs["postBindingAuthnRequest"] = nil
		inputs["postBindingLogout"] = nil
		inputs["postBindingResponse"] = nil
		inputs["postBrokerLoginFlowAlias"] = nil
		inputs["realm"] = nil
		inputs["signatureAlgorithm"] = nil
		inputs["signingCertificate"] = nil
		inputs["singleLogoutServiceUrl"] = nil
		inputs["singleSignOnServiceUrl"] = nil
		inputs["storeToken"] = nil
		inputs["trustEmail"] = nil
		inputs["validateSignature"] = nil
		inputs["wantAssertionsEncrypted"] = nil
		inputs["wantAssertionsSigned"] = nil
		inputs["xmlSignKeyInfoKeyNameTransformer"] = nil
	} else {
		inputs["addReadTokenRoleOnCreate"] = args.AddReadTokenRoleOnCreate
		inputs["alias"] = args.Alias
		inputs["authenticateByDefault"] = args.AuthenticateByDefault
		inputs["backchannelSupported"] = args.BackchannelSupported
		inputs["displayName"] = args.DisplayName
		inputs["enabled"] = args.Enabled
		inputs["firstBrokerLoginFlowAlias"] = args.FirstBrokerLoginFlowAlias
		inputs["forceAuthn"] = args.ForceAuthn
		inputs["hideOnLoginPage"] = args.HideOnLoginPage
		inputs["linkOnly"] = args.LinkOnly
		inputs["nameIdPolicyFormat"] = args.NameIdPolicyFormat
		inputs["postBindingAuthnRequest"] = args.PostBindingAuthnRequest
		inputs["postBindingLogout"] = args.PostBindingLogout
		inputs["postBindingResponse"] = args.PostBindingResponse
		inputs["postBrokerLoginFlowAlias"] = args.PostBrokerLoginFlowAlias
		inputs["realm"] = args.Realm
		inputs["signatureAlgorithm"] = args.SignatureAlgorithm
		inputs["signingCertificate"] = args.SigningCertificate
		inputs["singleLogoutServiceUrl"] = args.SingleLogoutServiceUrl
		inputs["singleSignOnServiceUrl"] = args.SingleSignOnServiceUrl
		inputs["storeToken"] = args.StoreToken
		inputs["trustEmail"] = args.TrustEmail
		inputs["validateSignature"] = args.ValidateSignature
		inputs["wantAssertionsEncrypted"] = args.WantAssertionsEncrypted
		inputs["wantAssertionsSigned"] = args.WantAssertionsSigned
		inputs["xmlSignKeyInfoKeyNameTransformer"] = args.XmlSignKeyInfoKeyNameTransformer
	}
	inputs["internalId"] = nil
	s, err := ctx.RegisterResource("keycloak:Saml/identityProvider:IdentityProvider", name, true, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &IdentityProvider{s: s}, nil
}

// GetIdentityProvider gets an existing IdentityProvider resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetIdentityProvider(ctx *pulumi.Context,
	name string, id pulumi.ID, state *IdentityProviderState, opts ...pulumi.ResourceOpt) (*IdentityProvider, error) {
	inputs := make(map[string]interface{})
	if state != nil {
		inputs["addReadTokenRoleOnCreate"] = state.AddReadTokenRoleOnCreate
		inputs["alias"] = state.Alias
		inputs["authenticateByDefault"] = state.AuthenticateByDefault
		inputs["backchannelSupported"] = state.BackchannelSupported
		inputs["displayName"] = state.DisplayName
		inputs["enabled"] = state.Enabled
		inputs["firstBrokerLoginFlowAlias"] = state.FirstBrokerLoginFlowAlias
		inputs["forceAuthn"] = state.ForceAuthn
		inputs["hideOnLoginPage"] = state.HideOnLoginPage
		inputs["internalId"] = state.InternalId
		inputs["linkOnly"] = state.LinkOnly
		inputs["nameIdPolicyFormat"] = state.NameIdPolicyFormat
		inputs["postBindingAuthnRequest"] = state.PostBindingAuthnRequest
		inputs["postBindingLogout"] = state.PostBindingLogout
		inputs["postBindingResponse"] = state.PostBindingResponse
		inputs["postBrokerLoginFlowAlias"] = state.PostBrokerLoginFlowAlias
		inputs["realm"] = state.Realm
		inputs["signatureAlgorithm"] = state.SignatureAlgorithm
		inputs["signingCertificate"] = state.SigningCertificate
		inputs["singleLogoutServiceUrl"] = state.SingleLogoutServiceUrl
		inputs["singleSignOnServiceUrl"] = state.SingleSignOnServiceUrl
		inputs["storeToken"] = state.StoreToken
		inputs["trustEmail"] = state.TrustEmail
		inputs["validateSignature"] = state.ValidateSignature
		inputs["wantAssertionsEncrypted"] = state.WantAssertionsEncrypted
		inputs["wantAssertionsSigned"] = state.WantAssertionsSigned
		inputs["xmlSignKeyInfoKeyNameTransformer"] = state.XmlSignKeyInfoKeyNameTransformer
	}
	s, err := ctx.ReadResource("keycloak:Saml/identityProvider:IdentityProvider", name, id, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &IdentityProvider{s: s}, nil
}

// URN is this resource's unique name assigned by Pulumi.
func (r *IdentityProvider) URN() pulumi.URNOutput {
	return r.s.URN()
}

// ID is this resource's unique identifier assigned by its provider.
func (r *IdentityProvider) ID() pulumi.IDOutput {
	return r.s.ID()
}

// Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.
func (r *IdentityProvider) AddReadTokenRoleOnCreate() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["addReadTokenRoleOnCreate"])
}

// The alias uniquely identifies an identity provider and it is also used to build the redirect uri.
func (r *IdentityProvider) Alias() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["alias"])
}

// Enable/disable authenticate users by default.
func (r *IdentityProvider) AuthenticateByDefault() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["authenticateByDefault"])
}

// Does the external IDP support backchannel logout?
func (r *IdentityProvider) BackchannelSupported() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["backchannelSupported"])
}

// Friendly name for Identity Providers.
func (r *IdentityProvider) DisplayName() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["displayName"])
}

// Enable/disable this identity provider.
func (r *IdentityProvider) Enabled() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["enabled"])
}

// Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means
// that there is not yet existing Keycloak account linked with the authenticated identity provider account.
func (r *IdentityProvider) FirstBrokerLoginFlowAlias() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["firstBrokerLoginFlowAlias"])
}

// Require Force Authn.
func (r *IdentityProvider) ForceAuthn() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["forceAuthn"])
}

// Hide On Login Page.
func (r *IdentityProvider) HideOnLoginPage() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["hideOnLoginPage"])
}

// Internal Identity Provider Id
func (r *IdentityProvider) InternalId() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["internalId"])
}

// If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't
// want to allow login from the provider, but want to integrate with a provider
func (r *IdentityProvider) LinkOnly() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["linkOnly"])
}

// Name ID Policy Format.
func (r *IdentityProvider) NameIdPolicyFormat() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["nameIdPolicyFormat"])
}

// Post Binding Authn Request.
func (r *IdentityProvider) PostBindingAuthnRequest() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["postBindingAuthnRequest"])
}

// Post Binding Logout.
func (r *IdentityProvider) PostBindingLogout() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["postBindingLogout"])
}

// Post Binding Response.
func (r *IdentityProvider) PostBindingResponse() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["postBindingResponse"])
}

// Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want
// additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if
// you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that
// authenticator implementations must assume that user is already set in ClientSession as identity provider already set it.
func (r *IdentityProvider) PostBrokerLoginFlowAlias() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["postBrokerLoginFlowAlias"])
}

// Realm Name
func (r *IdentityProvider) Realm() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["realm"])
}

// Signing Algorithm.
func (r *IdentityProvider) SignatureAlgorithm() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["signatureAlgorithm"])
}

// Signing Certificate.
func (r *IdentityProvider) SigningCertificate() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["signingCertificate"])
}

// Logout URL.
func (r *IdentityProvider) SingleLogoutServiceUrl() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["singleLogoutServiceUrl"])
}

// SSO Logout URL.
func (r *IdentityProvider) SingleSignOnServiceUrl() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["singleSignOnServiceUrl"])
}

// Enable/disable if tokens must be stored after authenticating users.
func (r *IdentityProvider) StoreToken() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["storeToken"])
}

// If enabled then email provided by this provider is not verified even if verification is enabled for the realm.
func (r *IdentityProvider) TrustEmail() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["trustEmail"])
}

// Enable/disable signature validation of SAML responses.
func (r *IdentityProvider) ValidateSignature() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["validateSignature"])
}

// Want Assertions Encrypted.
func (r *IdentityProvider) WantAssertionsEncrypted() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["wantAssertionsEncrypted"])
}

// Want Assertions Signed.
func (r *IdentityProvider) WantAssertionsSigned() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["wantAssertionsSigned"])
}

// Sign Key Transformer.
func (r *IdentityProvider) XmlSignKeyInfoKeyNameTransformer() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["xmlSignKeyInfoKeyNameTransformer"])
}

// Input properties used for looking up and filtering IdentityProvider resources.
type IdentityProviderState struct {
	// Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.
	AddReadTokenRoleOnCreate interface{}
	// The alias uniquely identifies an identity provider and it is also used to build the redirect uri.
	Alias interface{}
	// Enable/disable authenticate users by default.
	AuthenticateByDefault interface{}
	// Does the external IDP support backchannel logout?
	BackchannelSupported interface{}
	// Friendly name for Identity Providers.
	DisplayName interface{}
	// Enable/disable this identity provider.
	Enabled interface{}
	// Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login'
	// means that there is not yet existing Keycloak account linked with the authenticated identity provider account.
	FirstBrokerLoginFlowAlias interface{}
	// Require Force Authn.
	ForceAuthn interface{}
	// Hide On Login Page.
	HideOnLoginPage interface{}
	// Internal Identity Provider Id
	InternalId interface{}
	// If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't
	// want to allow login from the provider, but want to integrate with a provider
	LinkOnly interface{}
	// Name ID Policy Format.
	NameIdPolicyFormat interface{}
	// Post Binding Authn Request.
	PostBindingAuthnRequest interface{}
	// Post Binding Logout.
	PostBindingLogout interface{}
	// Post Binding Response.
	PostBindingResponse interface{}
	// Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want
	// additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if
	// you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that
	// authenticator implementations must assume that user is already set in ClientSession as identity provider already set
	// it.
	PostBrokerLoginFlowAlias interface{}
	// Realm Name
	Realm interface{}
	// Signing Algorithm.
	SignatureAlgorithm interface{}
	// Signing Certificate.
	SigningCertificate interface{}
	// Logout URL.
	SingleLogoutServiceUrl interface{}
	// SSO Logout URL.
	SingleSignOnServiceUrl interface{}
	// Enable/disable if tokens must be stored after authenticating users.
	StoreToken interface{}
	// If enabled then email provided by this provider is not verified even if verification is enabled for the realm.
	TrustEmail interface{}
	// Enable/disable signature validation of SAML responses.
	ValidateSignature interface{}
	// Want Assertions Encrypted.
	WantAssertionsEncrypted interface{}
	// Want Assertions Signed.
	WantAssertionsSigned interface{}
	// Sign Key Transformer.
	XmlSignKeyInfoKeyNameTransformer interface{}
}

// The set of arguments for constructing a IdentityProvider resource.
type IdentityProviderArgs struct {
	// Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.
	AddReadTokenRoleOnCreate interface{}
	// The alias uniquely identifies an identity provider and it is also used to build the redirect uri.
	Alias interface{}
	// Enable/disable authenticate users by default.
	AuthenticateByDefault interface{}
	// Does the external IDP support backchannel logout?
	BackchannelSupported interface{}
	// Friendly name for Identity Providers.
	DisplayName interface{}
	// Enable/disable this identity provider.
	Enabled interface{}
	// Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login'
	// means that there is not yet existing Keycloak account linked with the authenticated identity provider account.
	FirstBrokerLoginFlowAlias interface{}
	// Require Force Authn.
	ForceAuthn interface{}
	// Hide On Login Page.
	HideOnLoginPage interface{}
	// If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't
	// want to allow login from the provider, but want to integrate with a provider
	LinkOnly interface{}
	// Name ID Policy Format.
	NameIdPolicyFormat interface{}
	// Post Binding Authn Request.
	PostBindingAuthnRequest interface{}
	// Post Binding Logout.
	PostBindingLogout interface{}
	// Post Binding Response.
	PostBindingResponse interface{}
	// Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want
	// additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if
	// you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that
	// authenticator implementations must assume that user is already set in ClientSession as identity provider already set
	// it.
	PostBrokerLoginFlowAlias interface{}
	// Realm Name
	Realm interface{}
	// Signing Algorithm.
	SignatureAlgorithm interface{}
	// Signing Certificate.
	SigningCertificate interface{}
	// Logout URL.
	SingleLogoutServiceUrl interface{}
	// SSO Logout URL.
	SingleSignOnServiceUrl interface{}
	// Enable/disable if tokens must be stored after authenticating users.
	StoreToken interface{}
	// If enabled then email provided by this provider is not verified even if verification is enabled for the realm.
	TrustEmail interface{}
	// Enable/disable signature validation of SAML responses.
	ValidateSignature interface{}
	// Want Assertions Encrypted.
	WantAssertionsEncrypted interface{}
	// Want Assertions Signed.
	WantAssertionsSigned interface{}
	// Sign Key Transformer.
	XmlSignKeyInfoKeyNameTransformer interface{}
}
