{
    "name": "keycloak",
    "description": "A Pulumi package for creating and managing keycloak cloud resources.",
    "keywords": [
        "pulumi",
        "keycloak"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`keycloak` Terraform Provider](https://github.com/mrparkers/terraform-provider-keycloak).",
    "repository": "https://github.com/pulumi/pulumi-keycloak",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "config": {
        "variables": {
            "basePath": {
                "type": "string"
            },
            "clientId": {
                "type": "string",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_CLIENT_ID"
                    ]
                }
            },
            "clientSecret": {
                "type": "string",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_CLIENT_SECRET"
                    ]
                }
            },
            "clientTimeout": {
                "type": "integer",
                "description": "Timeout (in seconds) of the Keycloak client\n",
                "default": 5,
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_CLIENT_TIMEOUT"
                    ]
                }
            },
            "initialLogin": {
                "type": "boolean",
                "description": "Whether or not to login to Keycloak instance on provider initialization\n"
            },
            "password": {
                "type": "string",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_PASSWORD"
                    ]
                }
            },
            "realm": {
                "type": "string",
                "default": "master",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_REALM"
                    ]
                }
            },
            "rootCaCertificate": {
                "type": "string",
                "description": "Allows x509 calls using an unknown CA certificate (for development purposes)\n"
            },
            "tlsInsecureSkipVerify": {
                "type": "boolean",
                "description": "Allows ignoring insecure certificates when set to true. Defaults to false. Disabling security check is dangerous and\nshould be avoided.\n"
            },
            "url": {
                "type": "string",
                "description": "The base URL of the Keycloak instance, before `/auth`\n",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_URL"
                    ]
                }
            },
            "username": {
                "type": "string",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_USER"
                    ]
                }
            }
        },
        "defaults": [
            "clientId",
            "url"
        ]
    },
    "types": {
        "keycloak:/RealmInternationalization:RealmInternationalization": {
            "properties": {
                "defaultLocale": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "supportedLocales": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "defaultLocale",
                "supportedLocales"
            ]
        },
        "keycloak:/RealmSecurityDefenses:RealmSecurityDefenses": {
            "properties": {
                "bruteForceDetection": {
                    "$ref": "#/types/keycloak:/RealmSecurityDefensesBruteForceDetection:RealmSecurityDefensesBruteForceDetection",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "headers": {
                    "$ref": "#/types/keycloak:/RealmSecurityDefensesHeaders:RealmSecurityDefensesHeaders",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:/RealmSecurityDefensesBruteForceDetection:RealmSecurityDefensesBruteForceDetection": {
            "properties": {
                "failureResetTimeSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxFailureWaitSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxLoginFailures": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minimumQuickLoginWaitSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "permanentLockout": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "quickLoginCheckMilliSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "waitIncrementSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:/RealmSecurityDefensesHeaders:RealmSecurityDefensesHeaders": {
            "properties": {
                "contentSecurityPolicy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "contentSecurityPolicyReportOnly": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "strictTransportSecurity": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xContentTypeOptions": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xFrameOptions": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xRobotsTag": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xXssProtection": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:/RealmSmtpServer:RealmSmtpServer": {
            "properties": {
                "auth": {
                    "$ref": "#/types/keycloak:/RealmSmtpServerAuth:RealmSmtpServerAuth",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "envelopeFrom": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "from": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fromDisplayName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replyTo": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replyToDisplayName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ssl": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "starttls": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "from",
                "host"
            ]
        },
        "keycloak:/RealmSmtpServerAuth:RealmSmtpServerAuth": {
            "properties": {
                "password": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "password",
                "username"
            ]
        },
        "keycloak:/UserFederatedIdentity:UserFederatedIdentity": {
            "properties": {
                "identityProvider": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "identityProvider",
                "userId",
                "userName"
            ]
        },
        "keycloak:/UserInitialPassword:UserInitialPassword": {
            "properties": {
                "temporary": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "value"
            ]
        },
        "keycloak:/getRealmInternationalization:getRealmInternationalization": {
            "properties": {
                "defaultLocale": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "supportedLocales": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "defaultLocale",
                "supportedLocales"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:/getRealmKeysKey:getRealmKeysKey": {
            "properties": {
                "algorithm": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "kid": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerPriority": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "publicKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "algorithm",
                "certificate",
                "kid",
                "providerId",
                "providerPriority",
                "publicKey",
                "status",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:/getRealmSecurityDefense:getRealmSecurityDefense": {
            "properties": {
                "bruteForceDetections": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:/getRealmSecurityDefenseBruteForceDetection:getRealmSecurityDefenseBruteForceDetection"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:/getRealmSecurityDefenseHeader:getRealmSecurityDefenseHeader"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "bruteForceDetections",
                "headers"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:/getRealmSecurityDefenseBruteForceDetection:getRealmSecurityDefenseBruteForceDetection": {
            "properties": {
                "failureResetTimeSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxFailureWaitSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxLoginFailures": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minimumQuickLoginWaitSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "permanentLockout": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "quickLoginCheckMilliSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "waitIncrementSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "failureResetTimeSeconds",
                "maxFailureWaitSeconds",
                "maxLoginFailures",
                "minimumQuickLoginWaitSeconds",
                "permanentLockout",
                "quickLoginCheckMilliSeconds",
                "waitIncrementSeconds"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:/getRealmSecurityDefenseHeader:getRealmSecurityDefenseHeader": {
            "properties": {
                "contentSecurityPolicy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "contentSecurityPolicyReportOnly": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "strictTransportSecurity": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xContentTypeOptions": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xFrameOptions": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xRobotsTag": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xXssProtection": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "contentSecurityPolicy",
                "contentSecurityPolicyReportOnly",
                "strictTransportSecurity",
                "xContentTypeOptions",
                "xFrameOptions",
                "xRobotsTag",
                "xXssProtection"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:/getRealmSmtpServer:getRealmSmtpServer": {
            "properties": {
                "auths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:/getRealmSmtpServerAuth:getRealmSmtpServerAuth"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "envelopeFrom": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "from": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fromDisplayName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replyTo": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replyToDisplayName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ssl": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "starttls": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "auths",
                "envelopeFrom",
                "from",
                "fromDisplayName",
                "host",
                "port",
                "replyTo",
                "replyToDisplayName",
                "ssl",
                "starttls"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:/getRealmSmtpServerAuth:getRealmSmtpServerAuth": {
            "properties": {
                "password": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "password",
                "username"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:ldap/UserFederationKerberos:UserFederationKerberos": {
            "properties": {
                "kerberosRealm": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyTab": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serverPrincipal": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "useKerberosForPasswordAuthentication": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "kerberosRealm",
                "keyTab",
                "serverPrincipal"
            ]
        },
        "keycloak:openid/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides": {
            "properties": {
                "browserId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "directGrantId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:openid/ClientAuthorization:ClientAuthorization": {
            "properties": {
                "allowRemoteResourceManagement": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keepDefaults": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policyEnforcementMode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "policyEnforcementMode"
            ]
        },
        "keycloak:openid/ClientGroupPolicyGroup:ClientGroupPolicyGroup": {
            "properties": {
                "extendChildren": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "extendChildren",
                "id",
                "path"
            ]
        },
        "keycloak:openid/ClientRolePolicyRole:ClientRolePolicyRole": {
            "properties": {
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "required": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "id",
                "required"
            ]
        },
        "keycloak:openid/getClientAuthenticationFlowBindingOverrides:getClientAuthenticationFlowBindingOverrides": {
            "properties": {
                "browserId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "directGrantId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "browserId",
                "directGrantId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:openid/getClientAuthorization:getClientAuthorization": {
            "properties": {
                "allowRemoteResourceManagement": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policyEnforcementMode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "allowRemoteResourceManagement",
                "policyEnforcementMode"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:openid/getClientServiceAccountUserFederatedIdentity:getClientServiceAccountUserFederatedIdentity": {
            "properties": {
                "identityProvider": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "identityProvider",
                "userId",
                "userName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the keycloak package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "inputProperties": {
            "basePath": {
                "type": "string"
            },
            "clientId": {
                "type": "string",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_CLIENT_ID"
                    ]
                }
            },
            "clientSecret": {
                "type": "string",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_CLIENT_SECRET"
                    ]
                }
            },
            "clientTimeout": {
                "type": "integer",
                "description": "Timeout (in seconds) of the Keycloak client\n",
                "default": 5,
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_CLIENT_TIMEOUT"
                    ]
                }
            },
            "initialLogin": {
                "type": "boolean",
                "description": "Whether or not to login to Keycloak instance on provider initialization\n"
            },
            "password": {
                "type": "string",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_PASSWORD"
                    ]
                }
            },
            "realm": {
                "type": "string",
                "default": "master",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_REALM"
                    ]
                }
            },
            "rootCaCertificate": {
                "type": "string",
                "description": "Allows x509 calls using an unknown CA certificate (for development purposes)\n"
            },
            "tlsInsecureSkipVerify": {
                "type": "boolean",
                "description": "Allows ignoring insecure certificates when set to true. Defaults to false. Disabling security check is dangerous and\nshould be avoided.\n"
            },
            "url": {
                "type": "string",
                "description": "The base URL of the Keycloak instance, before `/auth`\n",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_URL"
                    ]
                }
            },
            "username": {
                "type": "string",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_USER"
                    ]
                }
            }
        }
    },
    "resources": {
        "keycloak:authentication/execution:Execution": {
            "description": "## # keycloak.authentication.Execution\n\nAllows for managing an authentication execution.\n\n### Example Usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst flow = new keycloak.authentication.Flow(\"flow\", {\n    alias: \"my-flow-alias\",\n    realmId: realm.id,\n});\nconst execution = new keycloak.authentication.Execution(\"execution\", {\n    authenticator: \"identity-provider-redirector\",\n    parentFlowAlias: flow.alias,\n    realmId: realm.id,\n    requirement: \"REQUIRED\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nflow = keycloak.authentication.Flow(\"flow\",\n    alias=\"my-flow-alias\",\n    realm_id=realm.id)\nexecution = keycloak.authentication.Execution(\"execution\",\n    authenticator=\"identity-provider-redirector\",\n    parent_flow_alias=flow.alias,\n    realm_id=realm.id,\n    requirement=\"REQUIRED\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var flow = new Keycloak.Authentication.Flow(\"flow\", new Keycloak.Authentication.FlowArgs\n        {\n            Alias = \"my-flow-alias\",\n            RealmId = realm.Id,\n        });\n        var execution = new Keycloak.Authentication.Execution(\"execution\", new Keycloak.Authentication.ExecutionArgs\n        {\n            Authenticator = \"identity-provider-redirector\",\n            ParentFlowAlias = flow.Alias,\n            RealmId = realm.Id,\n            Requirement = \"REQUIRED\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/authentication\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tflow, err := authentication.NewFlow(ctx, \"flow\", \u0026authentication.FlowArgs{\n\t\t\tAlias:   pulumi.String(\"my-flow-alias\"),\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = authentication.NewExecution(ctx, \"execution\", \u0026authentication.ExecutionArgs{\n\t\t\tAuthenticator:   pulumi.String(\"identity-provider-redirector\"),\n\t\t\tParentFlowAlias: flow.Alias,\n\t\t\tRealmId:         realm.ID(),\n\t\t\tRequirement:     pulumi.String(\"REQUIRED\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm the authentication execution exists in.\n- `parent_flow_alias` - (Required) The flow this execution is attached to.\n- `authenticator` - (Required) The name of the authenticator.\n- `requirement`- (Optional) The requirement setting, which can be one of the following:\n\t- `REQUIRED`\n\t- `ALTERNATIVE`\n\t- `DISABLED`\n",
            "properties": {
                "authenticator": {
                    "type": "string"
                },
                "parentFlowAlias": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "requirement": {
                    "type": "string"
                }
            },
            "required": [
                "authenticator",
                "parentFlowAlias",
                "realmId"
            ],
            "inputProperties": {
                "authenticator": {
                    "type": "string"
                },
                "parentFlowAlias": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "requirement": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "authenticator",
                "parentFlowAlias",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Execution resources.\n",
                "properties": {
                    "authenticator": {
                        "type": "string"
                    },
                    "parentFlowAlias": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "requirement": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:authentication/executionConfig:ExecutionConfig": {
            "description": "## # keycloak.authentication.ExecutionConfig\n\nAllows for managing an authentication execution configuration.\n\n### Example Usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst flow = new keycloak.authentication.Flow(\"flow\", {\n    alias: \"my-flow-alias\",\n    realmId: realm.id,\n});\nconst execution = new keycloak.authentication.Execution(\"execution\", {\n    authenticator: \"identity-provider-redirector\",\n    parentFlowAlias: flow.alias,\n    realmId: realm.id,\n});\nconst config = new keycloak.authentication.ExecutionConfig(\"config\", {\n    alias: \"my-config-alias\",\n    config: {\n        defaultProvider: \"my-config-default-idp\",\n    },\n    executionId: execution.id,\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nflow = keycloak.authentication.Flow(\"flow\",\n    alias=\"my-flow-alias\",\n    realm_id=realm.id)\nexecution = keycloak.authentication.Execution(\"execution\",\n    authenticator=\"identity-provider-redirector\",\n    parent_flow_alias=flow.alias,\n    realm_id=realm.id)\nconfig = keycloak.authentication.ExecutionConfig(\"config\",\n    alias=\"my-config-alias\",\n    config={\n        \"defaultProvider\": \"my-config-default-idp\",\n    },\n    execution_id=execution.id,\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var flow = new Keycloak.Authentication.Flow(\"flow\", new Keycloak.Authentication.FlowArgs\n        {\n            Alias = \"my-flow-alias\",\n            RealmId = realm.Id,\n        });\n        var execution = new Keycloak.Authentication.Execution(\"execution\", new Keycloak.Authentication.ExecutionArgs\n        {\n            Authenticator = \"identity-provider-redirector\",\n            ParentFlowAlias = flow.Alias,\n            RealmId = realm.Id,\n        });\n        var config = new Keycloak.Authentication.ExecutionConfig(\"config\", new Keycloak.Authentication.ExecutionConfigArgs\n        {\n            Alias = \"my-config-alias\",\n            Config = \n            {\n                { \"defaultProvider\", \"my-config-default-idp\" },\n            },\n            ExecutionId = execution.Id,\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/authentication\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tflow, err := authentication.NewFlow(ctx, \"flow\", \u0026authentication.FlowArgs{\n\t\t\tAlias:   pulumi.String(\"my-flow-alias\"),\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texecution, err := authentication.NewExecution(ctx, \"execution\", \u0026authentication.ExecutionArgs{\n\t\t\tAuthenticator:   pulumi.String(\"identity-provider-redirector\"),\n\t\t\tParentFlowAlias: flow.Alias,\n\t\t\tRealmId:         realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = authentication.NewExecutionConfig(ctx, \"config\", \u0026authentication.ExecutionConfigArgs{\n\t\t\tAlias: pulumi.String(\"my-config-alias\"),\n\t\t\tConfig: pulumi.StringMap{\n\t\t\t\t\"defaultProvider\": pulumi.String(\"my-config-default-idp\"),\n\t\t\t},\n\t\t\tExecutionId: execution.ID(),\n\t\t\tRealmId:     realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm the authentication execution exists in.\n- `execution_id` - (Required) The authentication execution this configuration is attached to.\n- `alias` - (Required) The name of the configuration.\n- `config` - (Optional) The configuration. Keys are specific to each configurable authentication execution and not checked when applying.\n",
            "properties": {
                "alias": {
                    "type": "string"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "executionId": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "alias",
                "config",
                "executionId",
                "realmId"
            ],
            "inputProperties": {
                "alias": {
                    "type": "string"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "executionId": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "alias",
                "config",
                "executionId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ExecutionConfig resources.\n",
                "properties": {
                    "alias": {
                        "type": "string"
                    },
                    "config": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "executionId": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:authentication/flow:Flow": {
            "properties": {
                "alias": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "providerId": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "alias",
                "realmId"
            ],
            "inputProperties": {
                "alias": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "providerId": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "alias",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Flow resources.\n",
                "properties": {
                    "alias": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "providerId": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:authentication/subflow:Subflow": {
            "properties": {
                "alias": {
                    "type": "string"
                },
                "authenticator": {
                    "type": "string",
                    "description": "Might be needed to be set with certain custom subflow with specific authenticator, in general this will remain empty\n"
                },
                "description": {
                    "type": "string"
                },
                "parentFlowAlias": {
                    "type": "string"
                },
                "providerId": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "requirement": {
                    "type": "string"
                }
            },
            "required": [
                "alias",
                "parentFlowAlias",
                "realmId"
            ],
            "inputProperties": {
                "alias": {
                    "type": "string"
                },
                "authenticator": {
                    "type": "string",
                    "description": "Might be needed to be set with certain custom subflow with specific authenticator, in general this will remain empty\n"
                },
                "description": {
                    "type": "string"
                },
                "parentFlowAlias": {
                    "type": "string"
                },
                "providerId": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "requirement": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "alias",
                "parentFlowAlias",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Subflow resources.\n",
                "properties": {
                    "alias": {
                        "type": "string"
                    },
                    "authenticator": {
                        "type": "string",
                        "description": "Might be needed to be set with certain custom subflow with specific authenticator, in general this will remain empty\n"
                    },
                    "description": {
                        "type": "string"
                    },
                    "parentFlowAlias": {
                        "type": "string"
                    },
                    "providerId": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "requirement": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/attributeImporterIdentityProviderMapper:AttributeImporterIdentityProviderMapper": {
            "description": "## # keycloak.AttributeImporterIdentityProviderMapper\n\nAllows to create and manage identity provider mappers within Keycloak.\n\n### Example Usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst testMapper = new keycloak.AttributeImporterIdentityProviderMapper(\"test_mapper\", {\n    attributeName: \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname\",\n    identityProviderAlias: \"idp_alias\",\n    realm: \"my-realm\",\n    userAttribute: \"lastName\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\ntest_mapper = keycloak.AttributeImporterIdentityProviderMapper(\"testMapper\",\n    attribute_name=\"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname\",\n    identity_provider_alias=\"idp_alias\",\n    realm=\"my-realm\",\n    user_attribute=\"lastName\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var testMapper = new Keycloak.AttributeImporterIdentityProviderMapper(\"testMapper\", new Keycloak.AttributeImporterIdentityProviderMapperArgs\n        {\n            AttributeName = \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname\",\n            IdentityProviderAlias = \"idp_alias\",\n            Realm = \"my-realm\",\n            UserAttribute = \"lastName\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := keycloak.NewAttributeImporterIdentityProviderMapper(ctx, \"testMapper\", \u0026keycloak.AttributeImporterIdentityProviderMapperArgs{\n\t\t\tAttributeName:         pulumi.String(\"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname\"),\n\t\t\tIdentityProviderAlias: pulumi.String(\"idp_alias\"),\n\t\t\tRealm:                 pulumi.String(\"my-realm\"),\n\t\t\tUserAttribute:         pulumi.String(\"lastName\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm` - (Required) The name of the realm.\n- `name` - (Required) The name of the mapper.\n- `identity_provider_alias` - (Required) The alias of the associated identity provider.\n- `user_attribute` - (Required) The user attribute name to store SAML attribute.\n- `attribute_name` - (Optional) The Name of attribute to search for in assertion. You can leave this blank and specify a friendly name instead.\n- `attribute_friendly_name` - (Optional) The friendly name of attribute to search for in assertion.  You can leave this blank and specify an attribute name instead.\n- `claim_name` - (Optional) The claim name.\n",
            "properties": {
                "attributeFriendlyName": {
                    "type": "string",
                    "description": "Attribute Friendly Name\n"
                },
                "attributeName": {
                    "type": "string",
                    "description": "Attribute Name\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "Claim Name\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "userAttribute": {
                    "type": "string",
                    "description": "User Attribute\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "name",
                "realm",
                "userAttribute"
            ],
            "inputProperties": {
                "attributeFriendlyName": {
                    "type": "string",
                    "description": "Attribute Friendly Name\n"
                },
                "attributeName": {
                    "type": "string",
                    "description": "Attribute Name\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "Claim Name\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "userAttribute": {
                    "type": "string",
                    "description": "User Attribute\n"
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "realm",
                "userAttribute"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AttributeImporterIdentityProviderMapper resources.\n",
                "properties": {
                    "attributeFriendlyName": {
                        "type": "string",
                        "description": "Attribute Friendly Name\n"
                    },
                    "attributeName": {
                        "type": "string",
                        "description": "Attribute Name\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "Claim Name\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "IDP Alias\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "IDP Mapper Name\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "Realm Name\n"
                    },
                    "userAttribute": {
                        "type": "string",
                        "description": "User Attribute\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/attributeToRoleIdentityMapper:AttributeToRoleIdentityMapper": {
            "properties": {
                "attributeFriendlyName": {
                    "type": "string",
                    "description": "Attribute Friendly Name\n"
                },
                "attributeName": {
                    "type": "string",
                    "description": "Attribute Name\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "Attribute Value\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "OIDC Claim Name\n"
                },
                "claimValue": {
                    "type": "string",
                    "description": "OIDC Claim Value\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role Name\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "name",
                "realm",
                "role"
            ],
            "inputProperties": {
                "attributeFriendlyName": {
                    "type": "string",
                    "description": "Attribute Friendly Name\n"
                },
                "attributeName": {
                    "type": "string",
                    "description": "Attribute Name\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "Attribute Value\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "OIDC Claim Name\n"
                },
                "claimValue": {
                    "type": "string",
                    "description": "OIDC Claim Value\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role Name\n"
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "realm",
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AttributeToRoleIdentityMapper resources.\n",
                "properties": {
                    "attributeFriendlyName": {
                        "type": "string",
                        "description": "Attribute Friendly Name\n"
                    },
                    "attributeName": {
                        "type": "string",
                        "description": "Attribute Name\n"
                    },
                    "attributeValue": {
                        "type": "string",
                        "description": "Attribute Value\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "OIDC Claim Name\n"
                    },
                    "claimValue": {
                        "type": "string",
                        "description": "OIDC Claim Value\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "IDP Alias\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "IDP Mapper Name\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "Realm Name\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "Role Name\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/customUserFederation:CustomUserFederation": {
            "properties": {
                "cachePolicy": {
                    "type": "string"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When false, this provider will not be used when performing queries for users.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the provider when displayed in the console.\n"
                },
                "parentId": {
                    "type": "string",
                    "description": "The parent_id of the generated component. will use realm_id if not specified.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of this provider when looking up users. Lower values are first.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The unique ID of the custom provider, specified in the `getId` implementation for the UserStorageProviderFactory\ninterface\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm (name) this provider will provide user federation for.\n"
                }
            },
            "required": [
                "name",
                "providerId",
                "realmId"
            ],
            "inputProperties": {
                "cachePolicy": {
                    "type": "string"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When false, this provider will not be used when performing queries for users.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the provider when displayed in the console.\n"
                },
                "parentId": {
                    "type": "string",
                    "description": "The parent_id of the generated component. will use realm_id if not specified.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of this provider when looking up users. Lower values are first.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The unique ID of the custom provider, specified in the `getId` implementation for the UserStorageProviderFactory\ninterface\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm (name) this provider will provide user federation for.\n"
                }
            },
            "requiredInputs": [
                "providerId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomUserFederation resources.\n",
                "properties": {
                    "cachePolicy": {
                        "type": "string"
                    },
                    "config": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When false, this provider will not be used when performing queries for users.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the provider when displayed in the console.\n"
                    },
                    "parentId": {
                        "type": "string",
                        "description": "The parent_id of the generated component. will use realm_id if not specified.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority of this provider when looking up users. Lower values are first.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "The unique ID of the custom provider, specified in the `getId` implementation for the UserStorageProviderFactory\ninterface\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm (name) this provider will provide user federation for.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/defaultGroups:DefaultGroups": {
            "description": "## # keycloak.DefaultGroups\n\nAllows for managing a realm's default groups.\n\nNote that you should not use `keycloak.DefaultGroups` with a group with memberships managed\nby `keycloak.GroupMemberships`.\n\n### Example Usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst group = new keycloak.Group(\"group\", {\n    realmId: realm.id,\n});\nconst defaultDefaultGroups = new keycloak.DefaultGroups(\"default\", {\n    groupIds: [group.id],\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\ngroup = keycloak.Group(\"group\", realm_id=realm.id)\ndefault = keycloak.DefaultGroups(\"default\",\n    group_ids=[group.id],\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var @group = new Keycloak.Group(\"group\", new Keycloak.GroupArgs\n        {\n            RealmId = realm.Id,\n        });\n        var @default = new Keycloak.DefaultGroups(\"default\", new Keycloak.DefaultGroupsArgs\n        {\n            GroupIds = \n            {\n                @group.Id,\n            },\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgroup, err := keycloak.NewGroup(ctx, \"group\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewDefaultGroups(ctx, \"_default\", \u0026keycloak.DefaultGroupsArgs{\n\t\t\tGroupIds: pulumi.StringArray{\n\t\t\t\tgroup.ID(),\n\t\t\t},\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this group exists in.\n- `group_ids` - (Required) A set of group ids that should be default groups on the realm referenced by `realm_id`.\n",
            "properties": {
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "groupIds",
                "realmId"
            ],
            "inputProperties": {
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "groupIds",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DefaultGroups resources.\n",
                "properties": {
                    "groupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/genericClientProtocolMapper:GenericClientProtocolMapper": {
            "description": "## # keycloak.GenericClientProtocolMapper\n\nAllows for creating and managing protocol mapper for both types of clients (openid-connect and saml) within Keycloak.\n\nThere are two uses cases for using this resource:\n* If you implemented a custom protocol mapper, this resource can be used to configure it\n* If the provider doesn't support a particular protocol mapper, this resource can be used instead.\n\nDue to the generic nature of this mapper, it is less user-friendly and more prone to configuration errors. \nTherefore, if possible, a specific mapper should be used.\n\n### Example Usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst samlClient = new keycloak.saml.Client(\"saml_client\", {\n    clientId: \"test-client\",\n    realmId: realm.id,\n});\nconst samlHardcodeAttributeMapper = new keycloak.GenericClientProtocolMapper(\"saml_hardcode_attribute_mapper\", {\n    clientId: samlClient.id,\n    config: {\n        \"attribute.name\": \"name\",\n        \"attribute.nameformat\": \"Basic\",\n        \"attribute.value\": \"value\",\n        \"friendly.name\": \"display name\",\n    },\n    protocol: \"saml\",\n    protocolMapper: \"saml-hardcode-attribute-mapper\",\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nsaml_client = keycloak.saml.Client(\"samlClient\",\n    client_id=\"test-client\",\n    realm_id=realm.id)\nsaml_hardcode_attribute_mapper = keycloak.GenericClientProtocolMapper(\"samlHardcodeAttributeMapper\",\n    client_id=saml_client.id,\n    config={\n        \"attribute.name\": \"name\",\n        \"attribute.nameformat\": \"Basic\",\n        \"attribute.value\": \"value\",\n        \"friendly.name\": \"display name\",\n    },\n    protocol=\"saml\",\n    protocol_mapper=\"saml-hardcode-attribute-mapper\",\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var samlClient = new Keycloak.Saml.Client(\"samlClient\", new Keycloak.Saml.ClientArgs\n        {\n            ClientId = \"test-client\",\n            RealmId = realm.Id,\n        });\n        var samlHardcodeAttributeMapper = new Keycloak.GenericClientProtocolMapper(\"samlHardcodeAttributeMapper\", new Keycloak.GenericClientProtocolMapperArgs\n        {\n            ClientId = samlClient.Id,\n            Config = \n            {\n                { \"attribute.name\", \"name\" },\n                { \"attribute.nameformat\", \"Basic\" },\n                { \"attribute.value\", \"value\" },\n                { \"friendly.name\", \"display name\" },\n            },\n            Protocol = \"saml\",\n            ProtocolMapper = \"saml-hardcode-attribute-mapper\",\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsamlClient, err := saml.NewClient(ctx, \"samlClient\", \u0026saml.ClientArgs{\n\t\t\tClientId: pulumi.String(\"test-client\"),\n\t\t\tRealmId:  realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericClientProtocolMapper(ctx, \"samlHardcodeAttributeMapper\", \u0026keycloak.GenericClientProtocolMapperArgs{\n\t\t\tClientId: samlClient.ID(),\n\t\t\tConfig: pulumi.StringMap{\n\t\t\t\t\"attribute.name\":       pulumi.String(\"name\"),\n\t\t\t\t\"attribute.nameformat\": pulumi.String(\"Basic\"),\n\t\t\t\t\"attribute.value\":      pulumi.String(\"value\"),\n\t\t\t\t\"friendly.name\":        pulumi.String(\"display name\"),\n\t\t\t},\n\t\t\tProtocol:       pulumi.String(\"saml\"),\n\t\t\tProtocolMapper: pulumi.String(\"saml-hardcode-attribute-mapper\"),\n\t\t\tRealmId:        realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required) The client this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `protocol` - (Required) The type of client (either `openid-connect` or `saml`). The type must match the type of the client.\n- `protocol_mapper` - (Required) The name of the protocol mapper. The protocol mapper must be\n   compatible with the specified client.\n- `config` - (Required) A map with key / value pairs for configuring the protocol mapper. The supported keys depends on the protocol mapper.\n",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The protocol of the client (openid-connect / saml).\n"
                },
                "protocolMapper": {
                    "type": "string",
                    "description": "The type of the protocol mapper.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                }
            },
            "required": [
                "config",
                "name",
                "protocol",
                "protocolMapper",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The protocol of the client (openid-connect / saml).\n"
                },
                "protocolMapper": {
                    "type": "string",
                    "description": "The type of the protocol mapper.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                }
            },
            "requiredInputs": [
                "config",
                "protocol",
                "protocolMapper",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GenericClientProtocolMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                    },
                    "config": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-friendly name that will appear in the Keycloak console.\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "The protocol of the client (openid-connect / saml).\n"
                    },
                    "protocolMapper": {
                        "type": "string",
                        "description": "The type of the protocol mapper.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id where the associated client or client scope exists.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/genericClientRoleMapper:GenericClientRoleMapper": {
            "description": "## # keycloak.GenericClientRoleMapper\n\nAllow for creating and managing a client's scope mappings within Keycloak.\n\nBy default, all the user role mappings of the user are added as claims within\nthe token or assertion. When `full_scope_allowed` is set to `false` for a\nclient, role scope mapping allows you to limit the roles that get declared\ninside an access token for a client.\n\n### Example Usage (Realm Role to Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst realmRole = new keycloak.Role(\"realmRole\", {\n    realmId: realm.id,\n    description: \"My Realm Role\",\n});\nconst clientRoleMapper = new keycloak.GenericClientRoleMapper(\"clientRoleMapper\", {\n    realmId: realm.id,\n    clientId: client.id,\n    roleId: realmRole.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nrealm_role = keycloak.Role(\"realmRole\",\n    realm_id=realm.id,\n    description=\"My Realm Role\")\nclient_role_mapper = keycloak.GenericClientRoleMapper(\"clientRoleMapper\",\n    realm_id=realm.id,\n    client_id=client.id,\n    role_id=realm_role.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var client = new Keycloak.OpenId.Client(\"client\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"BEARER-ONLY\",\n        });\n        var realmRole = new Keycloak.Role(\"realmRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            Description = \"My Realm Role\",\n        });\n        var clientRoleMapper = new Keycloak.GenericClientRoleMapper(\"clientRoleMapper\", new Keycloak.GenericClientRoleMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = client.Id,\n            RoleId = realmRole.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient, err := openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmRole, err := keycloak.NewRole(ctx, \"realmRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericClientRoleMapper(ctx, \"clientRoleMapper\", \u0026keycloak.GenericClientRoleMapperArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: client.ID(),\n\t\t\tRoleId:   realmRole.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Example Usage (Client Role to Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientA = new keycloak.openid.Client(\"clientA\", {\n    realmId: realm.id,\n    clientId: \"client-a\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst clientRoleA = new keycloak.Role(\"clientRoleA\", {\n    realmId: realm.id,\n    clientId: clientA.id,\n    description: \"My Client Role\",\n});\nconst clientB = new keycloak.openid.Client(\"clientB\", {\n    realmId: realm.id,\n    clientId: \"client-b\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst clientRoleB = new keycloak.Role(\"clientRoleB\", {\n    realmId: realm.id,\n    clientId: clientB.id,\n    description: \"My Client Role\",\n});\nconst clientBRoleMapper = new keycloak.GenericClientRoleMapper(\"clientBRoleMapper\", {\n    realmId: realm.id,\n    clientId: keycloak_client.client_b.id,\n    roleId: clientRoleA.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_a = keycloak.openid.Client(\"clientA\",\n    realm_id=realm.id,\n    client_id=\"client-a\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nclient_role_a = keycloak.Role(\"clientRoleA\",\n    realm_id=realm.id,\n    client_id=client_a.id,\n    description=\"My Client Role\")\nclient_b = keycloak.openid.Client(\"clientB\",\n    realm_id=realm.id,\n    client_id=\"client-b\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nclient_role_b = keycloak.Role(\"clientRoleB\",\n    realm_id=realm.id,\n    client_id=client_b.id,\n    description=\"My Client Role\")\nclient_b_role_mapper = keycloak.GenericClientRoleMapper(\"clientBRoleMapper\",\n    realm_id=realm.id,\n    client_id=keycloak_client[\"client_b\"][\"id\"],\n    role_id=client_role_a.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientA = new Keycloak.OpenId.Client(\"clientA\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client-a\",\n            Enabled = true,\n            AccessType = \"BEARER-ONLY\",\n        });\n        var clientRoleA = new Keycloak.Role(\"clientRoleA\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            ClientId = clientA.Id,\n            Description = \"My Client Role\",\n        });\n        var clientB = new Keycloak.OpenId.Client(\"clientB\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client-b\",\n            Enabled = true,\n            AccessType = \"BEARER-ONLY\",\n        });\n        var clientRoleB = new Keycloak.Role(\"clientRoleB\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            ClientId = clientB.Id,\n            Description = \"My Client Role\",\n        });\n        var clientBRoleMapper = new Keycloak.GenericClientRoleMapper(\"clientBRoleMapper\", new Keycloak.GenericClientRoleMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = keycloak_client.Client_b.Id,\n            RoleId = clientRoleA.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientA, err := openid.NewClient(ctx, \"clientA\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client-a\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientRoleA, err := keycloak.NewRole(ctx, \"clientRoleA\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    clientA.ID(),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientB, err := openid.NewClient(ctx, \"clientB\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client-b\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"clientRoleB\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    clientB.ID(),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericClientRoleMapper(ctx, \"clientBRoleMapper\", \u0026keycloak.GenericClientRoleMapperArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: pulumi.Any(keycloak_client.Client_b.Id),\n\t\t\tRoleId:   clientRoleA.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Example Usage (Realm Role to Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst realmRole = new keycloak.Role(\"realmRole\", {\n    realmId: realm.id,\n    description: \"My Realm Role\",\n});\nconst clientRoleMapper = new keycloak.GenericClientRoleMapper(\"clientRoleMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    roleId: realmRole.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nrealm_role = keycloak.Role(\"realmRole\",\n    realm_id=realm.id,\n    description=\"My Realm Role\")\nclient_role_mapper = keycloak.GenericClientRoleMapper(\"clientRoleMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    role_id=realm_role.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var realmRole = new Keycloak.Role(\"realmRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            Description = \"My Realm Role\",\n        });\n        var clientRoleMapper = new Keycloak.GenericClientRoleMapper(\"clientRoleMapper\", new Keycloak.GenericClientRoleMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            RoleId = realmRole.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmRole, err := keycloak.NewRole(ctx, \"realmRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericClientRoleMapper(ctx, \"clientRoleMapper\", \u0026keycloak.GenericClientRoleMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tRoleId:        realmRole.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Example Usage (Client Role to Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst clientRole = new keycloak.Role(\"clientRole\", {\n    realmId: realm.id,\n    clientId: client.id,\n    description: \"My Client Role\",\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst clientBRoleMapper = new keycloak.GenericClientRoleMapper(\"clientBRoleMapper\", {\n    realmId: realm.id,\n    clientScopeId: keycloak_client_scope.client_scope.id,\n    roleId: clientRole.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nclient_role = keycloak.Role(\"clientRole\",\n    realm_id=realm.id,\n    client_id=client.id,\n    description=\"My Client Role\")\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nclient_b_role_mapper = keycloak.GenericClientRoleMapper(\"clientBRoleMapper\",\n    realm_id=realm.id,\n    client_scope_id=keycloak_client_scope[\"client_scope\"][\"id\"],\n    role_id=client_role.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var client = new Keycloak.OpenId.Client(\"client\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"BEARER-ONLY\",\n        });\n        var clientRole = new Keycloak.Role(\"clientRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            ClientId = client.Id,\n            Description = \"My Client Role\",\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var clientBRoleMapper = new Keycloak.GenericClientRoleMapper(\"clientBRoleMapper\", new Keycloak.GenericClientRoleMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = keycloak_client_scope.Client_scope.Id,\n            RoleId = clientRole.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient, err := openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientRole, err := keycloak.NewRole(ctx, \"clientRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    client.ID(),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericClientRoleMapper(ctx, \"clientBRoleMapper\", \u0026keycloak.GenericClientRoleMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: pulumi.Any(keycloak_client_scope.Client_scope.Id),\n\t\t\tRoleId:        clientRole.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arugments are supported:\n\n- `realm_id` - (Required) The realm this role mapper exists within\n- `client_id` - (Optional) The ID of the client this role mapper is added to\n- `client_scope_id` - (Optional) The ID of the client scope this role mapper is added to\n- `role_id` - (Required) The ID of the role to be added to this role mapper\n",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The destination client of the client role. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The destination client scope of the client role. Cannot be used at the same time as client_id.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "Id of the role to assign\n"
                }
            },
            "required": [
                "realmId",
                "roleId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The destination client of the client role. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The destination client scope of the client role. Cannot be used at the same time as client_id.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "Id of the role to assign\n"
                }
            },
            "requiredInputs": [
                "realmId",
                "roleId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GenericClientRoleMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The destination client of the client role. Cannot be used at the same time as client_scope_id.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The destination client scope of the client role. Cannot be used at the same time as client_id.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id where the associated client or client scope exists.\n"
                    },
                    "roleId": {
                        "type": "string",
                        "description": "Id of the role to assign\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/group:Group": {
            "description": "## # keycloak.Group\n\nAllows for creating and managing Groups within Keycloak.\n\nGroups provide a logical wrapping for users within Keycloak. Users within a\ngroup can share attributes and roles, and group membership can be mapped\nto a claim.\n\nAttributes can also be defined on Groups.\n\nGroups can also be federated from external data sources, such as LDAP or Active Directory.\nThis resource **should not** be used to manage groups that were created this way.\n\n### Example Usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst parentGroup = new keycloak.Group(\"parent_group\", {\n    realmId: realm.id,\n});\nconst childGroup = new keycloak.Group(\"child_group\", {\n    parentId: parentGroup.id,\n    realmId: realm.id,\n});\nconst childGroupWithOptionalAttributes = new keycloak.Group(\"child_group_with_optional_attributes\", {\n    attributes: {\n        key1: \"value1\",\n        key2: \"value2\",\n    },\n    parentId: parentGroup.id,\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nparent_group = keycloak.Group(\"parentGroup\", realm_id=realm.id)\nchild_group = keycloak.Group(\"childGroup\",\n    parent_id=parent_group.id,\n    realm_id=realm.id)\nchild_group_with_optional_attributes = keycloak.Group(\"childGroupWithOptionalAttributes\",\n    attributes={\n        \"key1\": \"value1\",\n        \"key2\": \"value2\",\n    },\n    parent_id=parent_group.id,\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var parentGroup = new Keycloak.Group(\"parentGroup\", new Keycloak.GroupArgs\n        {\n            RealmId = realm.Id,\n        });\n        var childGroup = new Keycloak.Group(\"childGroup\", new Keycloak.GroupArgs\n        {\n            ParentId = parentGroup.Id,\n            RealmId = realm.Id,\n        });\n        var childGroupWithOptionalAttributes = new Keycloak.Group(\"childGroupWithOptionalAttributes\", new Keycloak.GroupArgs\n        {\n            Attributes = \n            {\n                { \"key1\", \"value1\" },\n                { \"key2\", \"value2\" },\n            },\n            ParentId = parentGroup.Id,\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tparentGroup, err := keycloak.NewGroup(ctx, \"parentGroup\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGroup(ctx, \"childGroup\", \u0026keycloak.GroupArgs{\n\t\t\tParentId: parentGroup.ID(),\n\t\t\tRealmId:  realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGroup(ctx, \"childGroupWithOptionalAttributes\", \u0026keycloak.GroupArgs{\n\t\t\tAttributes: pulumi.StringMap{\n\t\t\t\t\"key1\": pulumi.String(\"value1\"),\n\t\t\t\t\"key2\": pulumi.String(\"value2\"),\n\t\t\t},\n\t\t\tParentId: parentGroup.ID(),\n\t\t\tRealmId:  realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this group exists in.\n- `parent_id` - (Optional) The ID of this group's parent. If omitted, this group will be defined at the root level.\n- `name` - (Required) The name of the group.\n- `attributes` - (Optional) A dict of key/value pairs to set as custom attributes for the group.\n\n### Attributes Reference\n\nIn addition to the arguments listed above, the following computed attributes are exported:\n\n- `path` - The complete path of the group. For example, the child group's path in the example configuration would be `/parent-group/child-group`.\n",
            "properties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "name": {
                    "type": "string"
                },
                "parentId": {
                    "type": "string"
                },
                "path": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "path",
                "realmId"
            ],
            "inputProperties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "name": {
                    "type": "string"
                },
                "parentId": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Group resources.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "name": {
                        "type": "string"
                    },
                    "parentId": {
                        "type": "string"
                    },
                    "path": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/groupMemberships:GroupMemberships": {
            "properties": {
                "groupId": {
                    "type": "string"
                },
                "members": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "members",
                "realmId"
            ],
            "inputProperties": {
                "groupId": {
                    "type": "string"
                },
                "members": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "members",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupMemberships resources.\n",
                "properties": {
                    "groupId": {
                        "type": "string"
                    },
                    "members": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/groupRoles:GroupRoles": {
            "properties": {
                "groupId": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "groupId",
                "realmId",
                "roleIds"
            ],
            "inputProperties": {
                "groupId": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "requiredInputs": [
                "groupId",
                "realmId",
                "roleIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupRoles resources.\n",
                "properties": {
                    "groupId": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "roleIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/hardcodedAttributeIdentityProviderMapper:HardcodedAttributeIdentityProviderMapper": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "description": "OIDC Claim\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "User Attribute\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "userSession": {
                    "type": "boolean",
                    "description": "Is Attribute Related To a User Session\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "name",
                "realm",
                "userSession"
            ],
            "inputProperties": {
                "attributeName": {
                    "type": "string",
                    "description": "OIDC Claim\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "User Attribute\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "userSession": {
                    "type": "boolean",
                    "description": "Is Attribute Related To a User Session\n"
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "realm",
                "userSession"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedAttributeIdentityProviderMapper resources.\n",
                "properties": {
                    "attributeName": {
                        "type": "string",
                        "description": "OIDC Claim\n"
                    },
                    "attributeValue": {
                        "type": "string",
                        "description": "User Attribute\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "IDP Alias\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "IDP Mapper Name\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "Realm Name\n"
                    },
                    "userSession": {
                        "type": "boolean",
                        "description": "Is Attribute Related To a User Session\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/hardcodedRoleIdentityMapper:HardcodedRoleIdentityMapper": {
            "properties": {
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role Name\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "name",
                "realm"
            ],
            "inputProperties": {
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role Name\n"
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "realm"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedRoleIdentityMapper resources.\n",
                "properties": {
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "IDP Alias\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "IDP Mapper Name\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "Realm Name\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "Role Name\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/identityProviderTokenExchangeScopePermission:IdentityProviderTokenExchangeScopePermission": {
            "properties": {
                "authorizationIdpResourceId": {
                    "type": "string",
                    "description": "Resource id representing the identity provider, this automatically created by keycloak\n"
                },
                "authorizationResourceServerId": {
                    "type": "string",
                    "description": "Resource server id representing the realm management client on which this permission is managed\n"
                },
                "authorizationTokenExchangeScopePermissionId": {
                    "type": "string",
                    "description": "Permission id representing the Permission with scope 'Token Exchange' and the resource 'authorization_idp_resource_id',\nthis automatically created by keycloak, the policy id will be set on this permission\n"
                },
                "clients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Ids of the clients for which a policy will be created and set on scope based token exchange permission\n"
                },
                "policyId": {
                    "type": "string",
                    "description": "Policy id that will be set on the scope based token exchange permission automatically created by enabling permissions on\nthe reference identity provider\n"
                },
                "policyType": {
                    "type": "string",
                    "description": "Type of policy that is created. At the moment only 'client' type is supported\n"
                },
                "providerAlias": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "authorizationIdpResourceId",
                "authorizationResourceServerId",
                "authorizationTokenExchangeScopePermissionId",
                "clients",
                "policyId",
                "providerAlias",
                "realmId"
            ],
            "inputProperties": {
                "clients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Ids of the clients for which a policy will be created and set on scope based token exchange permission\n"
                },
                "policyType": {
                    "type": "string",
                    "description": "Type of policy that is created. At the moment only 'client' type is supported\n"
                },
                "providerAlias": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "clients",
                "providerAlias",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IdentityProviderTokenExchangeScopePermission resources.\n",
                "properties": {
                    "authorizationIdpResourceId": {
                        "type": "string",
                        "description": "Resource id representing the identity provider, this automatically created by keycloak\n"
                    },
                    "authorizationResourceServerId": {
                        "type": "string",
                        "description": "Resource server id representing the realm management client on which this permission is managed\n"
                    },
                    "authorizationTokenExchangeScopePermissionId": {
                        "type": "string",
                        "description": "Permission id representing the Permission with scope 'Token Exchange' and the resource 'authorization_idp_resource_id',\nthis automatically created by keycloak, the policy id will be set on this permission\n"
                    },
                    "clients": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Ids of the clients for which a policy will be created and set on scope based token exchange permission\n"
                    },
                    "policyId": {
                        "type": "string",
                        "description": "Policy id that will be set on the scope based token exchange permission automatically created by enabling permissions on\nthe reference identity provider\n"
                    },
                    "policyType": {
                        "type": "string",
                        "description": "Type of policy that is created. At the moment only 'client' type is supported\n"
                    },
                    "providerAlias": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/realm:Realm": {
            "properties": {
                "accessCodeLifespan": {
                    "type": "string"
                },
                "accessCodeLifespanLogin": {
                    "type": "string"
                },
                "accessCodeLifespanUserAction": {
                    "type": "string"
                },
                "accessTokenLifespan": {
                    "type": "string"
                },
                "accessTokenLifespanForImplicitFlow": {
                    "type": "string"
                },
                "accountTheme": {
                    "type": "string"
                },
                "actionTokenGeneratedByAdminLifespan": {
                    "type": "string"
                },
                "actionTokenGeneratedByUserLifespan": {
                    "type": "string"
                },
                "adminTheme": {
                    "type": "string"
                },
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "browserFlow": {
                    "type": "string",
                    "description": "Which flow should be used for BrowserFlow\n"
                },
                "clientAuthenticationFlow": {
                    "type": "string",
                    "description": "Which flow should be used for ClientAuthenticationFlow\n"
                },
                "defaultSignatureAlgorithm": {
                    "type": "string"
                },
                "directGrantFlow": {
                    "type": "string",
                    "description": "Which flow should be used for DirectGrantFlow\n"
                },
                "displayName": {
                    "type": "string"
                },
                "displayNameHtml": {
                    "type": "string"
                },
                "dockerAuthenticationFlow": {
                    "type": "string",
                    "description": "Which flow should be used for DockerAuthenticationFlow\n"
                },
                "duplicateEmailsAllowed": {
                    "type": "boolean"
                },
                "editUsernameAllowed": {
                    "type": "boolean"
                },
                "emailTheme": {
                    "type": "string"
                },
                "enabled": {
                    "type": "boolean"
                },
                "internalId": {
                    "type": "string"
                },
                "internationalization": {
                    "$ref": "#/types/keycloak:/RealmInternationalization:RealmInternationalization"
                },
                "loginTheme": {
                    "type": "string"
                },
                "loginWithEmailAllowed": {
                    "type": "boolean"
                },
                "offlineSessionIdleTimeout": {
                    "type": "string"
                },
                "offlineSessionMaxLifespan": {
                    "type": "string"
                },
                "passwordPolicy": {
                    "type": "string",
                    "description": "String that represents the passwordPolicies that are in place. Each policy is separated with \" and \". Supported policies\ncan be found in the server-info providers page. example: \"upperCase(1) and length(8) and forceExpiredPasswordChange(365)\nand notUsername(undefined)\"\n"
                },
                "realm": {
                    "type": "string",
                    "language": {
                        "csharp": {
                            "name": "RealmName"
                        }
                    }
                },
                "refreshTokenMaxReuse": {
                    "type": "integer"
                },
                "registrationAllowed": {
                    "type": "boolean"
                },
                "registrationEmailAsUsername": {
                    "type": "boolean"
                },
                "registrationFlow": {
                    "type": "string",
                    "description": "Which flow should be used for RegistrationFlow\n"
                },
                "rememberMe": {
                    "type": "boolean"
                },
                "resetCredentialsFlow": {
                    "type": "string",
                    "description": "Which flow should be used for ResetCredentialsFlow\n"
                },
                "resetPasswordAllowed": {
                    "type": "boolean"
                },
                "revokeRefreshToken": {
                    "type": "boolean"
                },
                "securityDefenses": {
                    "$ref": "#/types/keycloak:/RealmSecurityDefenses:RealmSecurityDefenses"
                },
                "smtpServer": {
                    "$ref": "#/types/keycloak:/RealmSmtpServer:RealmSmtpServer"
                },
                "sslRequired": {
                    "type": "string",
                    "description": "SSL Required: Values can be 'none', 'external' or 'all'.\n"
                },
                "ssoSessionIdleTimeout": {
                    "type": "string"
                },
                "ssoSessionMaxLifespan": {
                    "type": "string"
                },
                "userManagedAccess": {
                    "type": "boolean"
                },
                "verifyEmail": {
                    "type": "boolean"
                }
            },
            "required": [
                "accessCodeLifespan",
                "accessCodeLifespanLogin",
                "accessCodeLifespanUserAction",
                "accessTokenLifespan",
                "accessTokenLifespanForImplicitFlow",
                "actionTokenGeneratedByAdminLifespan",
                "actionTokenGeneratedByUserLifespan",
                "duplicateEmailsAllowed",
                "editUsernameAllowed",
                "internalId",
                "loginWithEmailAllowed",
                "offlineSessionIdleTimeout",
                "offlineSessionMaxLifespan",
                "realm",
                "registrationAllowed",
                "registrationEmailAsUsername",
                "rememberMe",
                "resetPasswordAllowed",
                "ssoSessionIdleTimeout",
                "ssoSessionMaxLifespan",
                "verifyEmail"
            ],
            "inputProperties": {
                "accessCodeLifespan": {
                    "type": "string"
                },
                "accessCodeLifespanLogin": {
                    "type": "string"
                },
                "accessCodeLifespanUserAction": {
                    "type": "string"
                },
                "accessTokenLifespan": {
                    "type": "string"
                },
                "accessTokenLifespanForImplicitFlow": {
                    "type": "string"
                },
                "accountTheme": {
                    "type": "string"
                },
                "actionTokenGeneratedByAdminLifespan": {
                    "type": "string"
                },
                "actionTokenGeneratedByUserLifespan": {
                    "type": "string"
                },
                "adminTheme": {
                    "type": "string"
                },
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "browserFlow": {
                    "type": "string",
                    "description": "Which flow should be used for BrowserFlow\n"
                },
                "clientAuthenticationFlow": {
                    "type": "string",
                    "description": "Which flow should be used for ClientAuthenticationFlow\n"
                },
                "defaultSignatureAlgorithm": {
                    "type": "string"
                },
                "directGrantFlow": {
                    "type": "string",
                    "description": "Which flow should be used for DirectGrantFlow\n"
                },
                "displayName": {
                    "type": "string"
                },
                "displayNameHtml": {
                    "type": "string"
                },
                "dockerAuthenticationFlow": {
                    "type": "string",
                    "description": "Which flow should be used for DockerAuthenticationFlow\n"
                },
                "duplicateEmailsAllowed": {
                    "type": "boolean"
                },
                "editUsernameAllowed": {
                    "type": "boolean"
                },
                "emailTheme": {
                    "type": "string"
                },
                "enabled": {
                    "type": "boolean"
                },
                "internationalization": {
                    "$ref": "#/types/keycloak:/RealmInternationalization:RealmInternationalization"
                },
                "loginTheme": {
                    "type": "string"
                },
                "loginWithEmailAllowed": {
                    "type": "boolean"
                },
                "offlineSessionIdleTimeout": {
                    "type": "string"
                },
                "offlineSessionMaxLifespan": {
                    "type": "string"
                },
                "passwordPolicy": {
                    "type": "string",
                    "description": "String that represents the passwordPolicies that are in place. Each policy is separated with \" and \". Supported policies\ncan be found in the server-info providers page. example: \"upperCase(1) and length(8) and forceExpiredPasswordChange(365)\nand notUsername(undefined)\"\n"
                },
                "realm": {
                    "type": "string",
                    "language": {
                        "csharp": {
                            "name": "RealmName"
                        }
                    }
                },
                "refreshTokenMaxReuse": {
                    "type": "integer"
                },
                "registrationAllowed": {
                    "type": "boolean"
                },
                "registrationEmailAsUsername": {
                    "type": "boolean"
                },
                "registrationFlow": {
                    "type": "string",
                    "description": "Which flow should be used for RegistrationFlow\n"
                },
                "rememberMe": {
                    "type": "boolean"
                },
                "resetCredentialsFlow": {
                    "type": "string",
                    "description": "Which flow should be used for ResetCredentialsFlow\n"
                },
                "resetPasswordAllowed": {
                    "type": "boolean"
                },
                "revokeRefreshToken": {
                    "type": "boolean"
                },
                "securityDefenses": {
                    "$ref": "#/types/keycloak:/RealmSecurityDefenses:RealmSecurityDefenses"
                },
                "smtpServer": {
                    "$ref": "#/types/keycloak:/RealmSmtpServer:RealmSmtpServer"
                },
                "sslRequired": {
                    "type": "string",
                    "description": "SSL Required: Values can be 'none', 'external' or 'all'.\n"
                },
                "ssoSessionIdleTimeout": {
                    "type": "string"
                },
                "ssoSessionMaxLifespan": {
                    "type": "string"
                },
                "userManagedAccess": {
                    "type": "boolean"
                },
                "verifyEmail": {
                    "type": "boolean"
                }
            },
            "requiredInputs": [
                "realm"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Realm resources.\n",
                "properties": {
                    "accessCodeLifespan": {
                        "type": "string"
                    },
                    "accessCodeLifespanLogin": {
                        "type": "string"
                    },
                    "accessCodeLifespanUserAction": {
                        "type": "string"
                    },
                    "accessTokenLifespan": {
                        "type": "string"
                    },
                    "accessTokenLifespanForImplicitFlow": {
                        "type": "string"
                    },
                    "accountTheme": {
                        "type": "string"
                    },
                    "actionTokenGeneratedByAdminLifespan": {
                        "type": "string"
                    },
                    "actionTokenGeneratedByUserLifespan": {
                        "type": "string"
                    },
                    "adminTheme": {
                        "type": "string"
                    },
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "browserFlow": {
                        "type": "string",
                        "description": "Which flow should be used for BrowserFlow\n"
                    },
                    "clientAuthenticationFlow": {
                        "type": "string",
                        "description": "Which flow should be used for ClientAuthenticationFlow\n"
                    },
                    "defaultSignatureAlgorithm": {
                        "type": "string"
                    },
                    "directGrantFlow": {
                        "type": "string",
                        "description": "Which flow should be used for DirectGrantFlow\n"
                    },
                    "displayName": {
                        "type": "string"
                    },
                    "displayNameHtml": {
                        "type": "string"
                    },
                    "dockerAuthenticationFlow": {
                        "type": "string",
                        "description": "Which flow should be used for DockerAuthenticationFlow\n"
                    },
                    "duplicateEmailsAllowed": {
                        "type": "boolean"
                    },
                    "editUsernameAllowed": {
                        "type": "boolean"
                    },
                    "emailTheme": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "internalId": {
                        "type": "string"
                    },
                    "internationalization": {
                        "$ref": "#/types/keycloak:/RealmInternationalization:RealmInternationalization"
                    },
                    "loginTheme": {
                        "type": "string"
                    },
                    "loginWithEmailAllowed": {
                        "type": "boolean"
                    },
                    "offlineSessionIdleTimeout": {
                        "type": "string"
                    },
                    "offlineSessionMaxLifespan": {
                        "type": "string"
                    },
                    "passwordPolicy": {
                        "type": "string",
                        "description": "String that represents the passwordPolicies that are in place. Each policy is separated with \" and \". Supported policies\ncan be found in the server-info providers page. example: \"upperCase(1) and length(8) and forceExpiredPasswordChange(365)\nand notUsername(undefined)\"\n"
                    },
                    "realm": {
                        "type": "string",
                        "language": {
                            "csharp": {
                                "name": "RealmName"
                            }
                        }
                    },
                    "refreshTokenMaxReuse": {
                        "type": "integer"
                    },
                    "registrationAllowed": {
                        "type": "boolean"
                    },
                    "registrationEmailAsUsername": {
                        "type": "boolean"
                    },
                    "registrationFlow": {
                        "type": "string",
                        "description": "Which flow should be used for RegistrationFlow\n"
                    },
                    "rememberMe": {
                        "type": "boolean"
                    },
                    "resetCredentialsFlow": {
                        "type": "string",
                        "description": "Which flow should be used for ResetCredentialsFlow\n"
                    },
                    "resetPasswordAllowed": {
                        "type": "boolean"
                    },
                    "revokeRefreshToken": {
                        "type": "boolean"
                    },
                    "securityDefenses": {
                        "$ref": "#/types/keycloak:/RealmSecurityDefenses:RealmSecurityDefenses"
                    },
                    "smtpServer": {
                        "$ref": "#/types/keycloak:/RealmSmtpServer:RealmSmtpServer"
                    },
                    "sslRequired": {
                        "type": "string",
                        "description": "SSL Required: Values can be 'none', 'external' or 'all'.\n"
                    },
                    "ssoSessionIdleTimeout": {
                        "type": "string"
                    },
                    "ssoSessionMaxLifespan": {
                        "type": "string"
                    },
                    "userManagedAccess": {
                        "type": "boolean"
                    },
                    "verifyEmail": {
                        "type": "boolean"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/realmEvents:RealmEvents": {
            "description": "## # keycloak.RealmEvents\n\nAllows for managing Realm Events settings within Keycloak.\n\n### Example Usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"test\",\n});\nconst realmEvents = new keycloak.RealmEvents(\"realm_events\", {\n    adminEventsDetailsEnabled: true,\n    adminEventsEnabled: true,\n    // When omitted or left empty, keycloak will enable all event types\n    enabledEventTypes: [\n        \"LOGIN\",\n        \"LOGOUT\",\n    ],\n    eventsEnabled: true,\n    eventsExpiration: 3600,\n    eventsListeners: [\"jboss-logging\"],\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\", realm=\"test\")\nrealm_events = keycloak.RealmEvents(\"realmEvents\",\n    admin_events_details_enabled=True,\n    admin_events_enabled=True,\n    enabled_event_types=[\n        \"LOGIN\",\n        \"LOGOUT\",\n    ],\n    events_enabled=True,\n    events_expiration=3600,\n    events_listeners=[\"jboss-logging\"],\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"test\",\n        });\n        var realmEvents = new Keycloak.RealmEvents(\"realmEvents\", new Keycloak.RealmEventsArgs\n        {\n            AdminEventsDetailsEnabled = true,\n            AdminEventsEnabled = true,\n            EnabledEventTypes = \n            {\n                \"LOGIN\",\n                \"LOGOUT\",\n            },\n            EventsEnabled = true,\n            EventsExpiration = 3600,\n            EventsListeners = \n            {\n                \"jboss-logging\",\n            },\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm: pulumi.String(\"test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRealmEvents(ctx, \"realmEvents\", \u0026keycloak.RealmEventsArgs{\n\t\t\tAdminEventsDetailsEnabled: pulumi.Bool(true),\n\t\t\tAdminEventsEnabled:        pulumi.Bool(true),\n\t\t\tEnabledEventTypes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"LOGIN\"),\n\t\t\t\tpulumi.String(\"LOGOUT\"),\n\t\t\t},\n\t\t\tEventsEnabled:    pulumi.Bool(true),\n\t\t\tEventsExpiration: pulumi.Int(3600),\n\t\t\tEventsListeners: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"jboss-logging\"),\n\t\t\t},\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The name of the realm the event settings apply to.\n- `admin_events_enabled` - (Optional) When true, admin events are saved to the database, making them available through the admin console. Defaults to `false`.\n- `admin_events_details_enabled` - (Optional) When true, saved admin events will included detailed information for create/update requests. Defaults to `false`.\n- `events_enabled` - (Optional) When true, events from `enabled_event_types` are saved to the database, making them available through the admin console. Defaults to `false`.\n- `events_expiration` - (Optional) The amount of time in seconds events will be saved in the database. Defaults to `0` or never.\n- `enabled_event_types` - (Optional) The event types that will be saved to the database. Omitting this field enables all event types. Defaults to `[]` or all event types.\n- `events_listeners` - (Optional) The event listeners that events should be sent to. Defaults to `[]` or none. Note that new realms enable the `jboss-logging` listener by default, and this resource will remove that unless it is specified.\n",
            "properties": {
                "adminEventsDetailsEnabled": {
                    "type": "boolean"
                },
                "adminEventsEnabled": {
                    "type": "boolean"
                },
                "enabledEventTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "eventsEnabled": {
                    "type": "boolean"
                },
                "eventsExpiration": {
                    "type": "integer"
                },
                "eventsListeners": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "realmId"
            ],
            "inputProperties": {
                "adminEventsDetailsEnabled": {
                    "type": "boolean"
                },
                "adminEventsEnabled": {
                    "type": "boolean"
                },
                "enabledEventTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "eventsEnabled": {
                    "type": "boolean"
                },
                "eventsExpiration": {
                    "type": "integer"
                },
                "eventsListeners": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RealmEvents resources.\n",
                "properties": {
                    "adminEventsDetailsEnabled": {
                        "type": "boolean"
                    },
                    "adminEventsEnabled": {
                        "type": "boolean"
                    },
                    "enabledEventTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "eventsEnabled": {
                        "type": "boolean"
                    },
                    "eventsExpiration": {
                        "type": "integer"
                    },
                    "eventsListeners": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/requiredAction:RequiredAction": {
            "properties": {
                "alias": {
                    "type": "string"
                },
                "defaultAction": {
                    "type": "boolean"
                },
                "enabled": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "priority": {
                    "type": "integer"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "alias",
                "name",
                "priority",
                "realmId"
            ],
            "inputProperties": {
                "alias": {
                    "type": "string"
                },
                "defaultAction": {
                    "type": "boolean"
                },
                "enabled": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "priority": {
                    "type": "integer"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "alias",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RequiredAction resources.\n",
                "properties": {
                    "alias": {
                        "type": "string"
                    },
                    "defaultAction": {
                        "type": "boolean"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "priority": {
                        "type": "integer"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/role:Role": {
            "description": "## # keycloak.Role\n\nAllows for creating and managing roles within Keycloak.\n\nRoles allow you define privileges within Keycloak and map them to users\nand groups.\n\n### Example Usage (Realm role)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst realmRole = new keycloak.Role(\"realm_role\", {\n    description: \"My Realm Role\",\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nrealm_role = keycloak.Role(\"realmRole\",\n    description=\"My Realm Role\",\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var realmRole = new Keycloak.Role(\"realmRole\", new Keycloak.RoleArgs\n        {\n            Description = \"My Realm Role\",\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"realmRole\", \u0026keycloak.RoleArgs{\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t\tRealmId:     realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Example Usage (Client role)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    accessType: \"BEARER-ONLY\",\n    clientId: \"client\",\n    enabled: true,\n    realmId: realm.id,\n});\nconst clientRole = new keycloak.Role(\"client_role\", {\n    clientId: keycloak_client_client.id,\n    description: \"My Client Role\",\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nclient = keycloak.openid.Client(\"client\",\n    access_type=\"BEARER-ONLY\",\n    client_id=\"client\",\n    enabled=True,\n    realm_id=realm.id)\nclient_role = keycloak.Role(\"clientRole\",\n    client_id=keycloak_client[\"client\"][\"id\"],\n    description=\"My Client Role\",\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var client = new Keycloak.OpenId.Client(\"client\", new Keycloak.OpenId.ClientArgs\n        {\n            AccessType = \"BEARER-ONLY\",\n            ClientId = \"client\",\n            Enabled = true,\n            RealmId = realm.Id,\n        });\n        var clientRole = new Keycloak.Role(\"clientRole\", new Keycloak.RoleArgs\n        {\n            ClientId = keycloak_client.Client.Id,\n            Description = \"My Client Role\",\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tRealmId:    realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"clientRole\", \u0026keycloak.RoleArgs{\n\t\t\tClientId:    pulumi.Any(keycloak_client.Client.Id),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t\tRealmId:     realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Example Usage (Composite role)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst createRole = new keycloak.Role(\"create_role\", {\n    realmId: realm.id,\n});\nconst readRole = new keycloak.Role(\"read_role\", {\n    realmId: realm.id,\n});\nconst updateRole = new keycloak.Role(\"update_role\", {\n    realmId: realm.id,\n});\nconst deleteRole = new keycloak.Role(\"delete_role\", {\n    realmId: realm.id,\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    accessType: \"BEARER-ONLY\",\n    clientId: \"client\",\n    enabled: true,\n    realmId: realm.id,\n});\nconst clientRole = new keycloak.Role(\"client_role\", {\n    clientId: keycloak_client_client.id,\n    description: \"My Client Role\",\n    realmId: realm.id,\n});\nconst adminRole = new keycloak.Role(\"admin_role\", {\n    compositeRoles: [\n        \"{keycloak_role.create_role.id}\",\n        \"{keycloak_role.read_role.id}\",\n        \"{keycloak_role.update_role.id}\",\n        \"{keycloak_role.delete_role.id}\",\n        \"{keycloak_role.client_role.id}\",\n    ],\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\ncreate_role = keycloak.Role(\"createRole\", realm_id=realm.id)\nread_role = keycloak.Role(\"readRole\", realm_id=realm.id)\nupdate_role = keycloak.Role(\"updateRole\", realm_id=realm.id)\ndelete_role = keycloak.Role(\"deleteRole\", realm_id=realm.id)\nclient = keycloak.openid.Client(\"client\",\n    access_type=\"BEARER-ONLY\",\n    client_id=\"client\",\n    enabled=True,\n    realm_id=realm.id)\nclient_role = keycloak.Role(\"clientRole\",\n    client_id=keycloak_client[\"client\"][\"id\"],\n    description=\"My Client Role\",\n    realm_id=realm.id)\nadmin_role = keycloak.Role(\"adminRole\",\n    composite_roles=[\n        \"{keycloak_role.create_role.id}\",\n        \"{keycloak_role.read_role.id}\",\n        \"{keycloak_role.update_role.id}\",\n        \"{keycloak_role.delete_role.id}\",\n        \"{keycloak_role.client_role.id}\",\n    ],\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var createRole = new Keycloak.Role(\"createRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n        });\n        var readRole = new Keycloak.Role(\"readRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n        });\n        var updateRole = new Keycloak.Role(\"updateRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n        });\n        var deleteRole = new Keycloak.Role(\"deleteRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n        });\n        var client = new Keycloak.OpenId.Client(\"client\", new Keycloak.OpenId.ClientArgs\n        {\n            AccessType = \"BEARER-ONLY\",\n            ClientId = \"client\",\n            Enabled = true,\n            RealmId = realm.Id,\n        });\n        var clientRole = new Keycloak.Role(\"clientRole\", new Keycloak.RoleArgs\n        {\n            ClientId = keycloak_client.Client.Id,\n            Description = \"My Client Role\",\n            RealmId = realm.Id,\n        });\n        var adminRole = new Keycloak.Role(\"adminRole\", new Keycloak.RoleArgs\n        {\n            CompositeRoles = \n            {\n                \"{keycloak_role.create_role.id}\",\n                \"{keycloak_role.read_role.id}\",\n                \"{keycloak_role.update_role.id}\",\n                \"{keycloak_role.delete_role.id}\",\n                \"{keycloak_role.client_role.id}\",\n            },\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"createRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"readRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"updateRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"deleteRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tRealmId:    realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"clientRole\", \u0026keycloak.RoleArgs{\n\t\t\tClientId:    pulumi.Any(keycloak_client.Client.Id),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t\tRealmId:     realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"adminRole\", \u0026keycloak.RoleArgs{\n\t\t\tCompositeRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"{keycloak_role.create_role.id}\"),\n\t\t\t\tpulumi.String(\"{keycloak_role.read_role.id}\"),\n\t\t\t\tpulumi.String(\"{keycloak_role.update_role.id}\"),\n\t\t\t\tpulumi.String(\"{keycloak_role.delete_role.id}\"),\n\t\t\t\tpulumi.String(\"{keycloak_role.client_role.id}\"),\n\t\t\t},\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this role exists within.\n- `client_id` - (Optional) When specified, this role will be created as\n  a client role attached to the client with the provided ID\n- `name` - (Required) The name of the role\n- `description` - (Optional) The description of the role\n- `composite_roles` - (Optional) When specified, this role will be a\n  composite role, composed of all roles that have an ID present within\n  this list.\n\n",
            "properties": {
                "clientId": {
                    "type": "string"
                },
                "compositeRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string"
                },
                "compositeRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Role resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string"
                    },
                    "compositeRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "description": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/user:User": {
            "properties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "email": {
                    "type": "string"
                },
                "emailVerified": {
                    "type": "boolean"
                },
                "enabled": {
                    "type": "boolean"
                },
                "federatedIdentities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:/UserFederatedIdentity:UserFederatedIdentity"
                    }
                },
                "firstName": {
                    "type": "string"
                },
                "initialPassword": {
                    "$ref": "#/types/keycloak:/UserInitialPassword:UserInitialPassword"
                },
                "lastName": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            },
            "required": [
                "realmId",
                "username"
            ],
            "inputProperties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "email": {
                    "type": "string"
                },
                "emailVerified": {
                    "type": "boolean"
                },
                "enabled": {
                    "type": "boolean"
                },
                "federatedIdentities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:/UserFederatedIdentity:UserFederatedIdentity"
                    }
                },
                "firstName": {
                    "type": "string"
                },
                "initialPassword": {
                    "$ref": "#/types/keycloak:/UserInitialPassword:UserInitialPassword"
                },
                "lastName": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering User resources.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "email": {
                        "type": "string"
                    },
                    "emailVerified": {
                        "type": "boolean"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "federatedIdentities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:/UserFederatedIdentity:UserFederatedIdentity"
                        }
                    },
                    "firstName": {
                        "type": "string"
                    },
                    "initialPassword": {
                        "$ref": "#/types/keycloak:/UserInitialPassword:UserInitialPassword"
                    },
                    "lastName": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "username": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/userRoles:UserRoles": {
            "properties": {
                "realmId": {
                    "type": "string"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "userId": {
                    "type": "string"
                }
            },
            "required": [
                "realmId",
                "roleIds",
                "userId"
            ],
            "inputProperties": {
                "realmId": {
                    "type": "string"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "userId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId",
                "roleIds",
                "userId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserRoles resources.\n",
                "properties": {
                    "realmId": {
                        "type": "string"
                    },
                    "roleIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "userId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/userTemplateImporterIdentityProviderMapper:UserTemplateImporterIdentityProviderMapper": {
            "properties": {
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "template": {
                    "type": "string",
                    "description": "Username For Template Import\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "name",
                "realm"
            ],
            "inputProperties": {
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "template": {
                    "type": "string",
                    "description": "Username For Template Import\n"
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "realm"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserTemplateImporterIdentityProviderMapper resources.\n",
                "properties": {
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "IDP Alias\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "IDP Mapper Name\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "Realm Name\n"
                    },
                    "template": {
                        "type": "string",
                        "description": "Username For Template Import\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/fullNameMapper:FullNameMapper": {
            "description": "## # keycloak.ldap.FullNameMapper\n\nAllows for creating and managing full name mappers for Keycloak users federated\nvia LDAP.\n\nThe LDAP full name mapper can map a user's full name from an LDAP attribute\nto the first and last name attributes of a Keycloak user.\n\n### Example Usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"test\",\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldap_user_federation\", {\n    bindCredential: \"admin\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    connectionUrl: \"ldap://openldap\",\n    rdnLdapAttribute: \"cn\",\n    realmId: realm.id,\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    usernameLdapAttribute: \"cn\",\n    usersDn: \"dc=example,dc=org\",\n    uuidLdapAttribute: \"entryDN\",\n});\nconst ldapFullNameMapper = new keycloak.ldap.FullNameMapper(\"ldap_full_name_mapper\", {\n    ldapFullNameAttribute: \"cn\",\n    ldapUserFederationId: ldapUserFederation.id,\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"test\")\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    bind_credential=\"admin\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    connection_url=\"ldap://openldap\",\n    rdn_ldap_attribute=\"cn\",\n    realm_id=realm.id,\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    username_ldap_attribute=\"cn\",\n    users_dn=\"dc=example,dc=org\",\n    uuid_ldap_attribute=\"entryDN\")\nldap_full_name_mapper = keycloak.ldap.FullNameMapper(\"ldapFullNameMapper\",\n    ldap_full_name_attribute=\"cn\",\n    ldap_user_federation_id=ldap_user_federation.id,\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"test\",\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            BindCredential = \"admin\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            ConnectionUrl = \"ldap://openldap\",\n            RdnLdapAttribute = \"cn\",\n            RealmId = realm.Id,\n            UserObjectClasses = \n            {\n                \"simpleSecurityObject\",\n                \"organizationalRole\",\n            },\n            UsernameLdapAttribute = \"cn\",\n            UsersDn = \"dc=example,dc=org\",\n            UuidLdapAttribute = \"entryDN\",\n        });\n        var ldapFullNameMapper = new Keycloak.Ldap.FullNameMapper(\"ldapFullNameMapper\", new Keycloak.Ldap.FullNameMapperArgs\n        {\n            LdapFullNameAttribute = \"cn\",\n            LdapUserFederationId = ldapUserFederation.Id,\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tBindCredential:   pulumi.String(\"admin\"),\n\t\t\tBindDn:           pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tConnectionUrl:    pulumi.String(\"ldap://openldap\"),\n\t\t\tRdnLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRealmId:          realm.ID(),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tUsersDn:               pulumi.String(\"dc=example,dc=org\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewFullNameMapper(ctx, \"ldapFullNameMapper\", \u0026ldap.FullNameMapperArgs{\n\t\t\tLdapFullNameAttribute: pulumi.String(\"cn\"),\n\t\t\tLdapUserFederationId:  ldapUserFederation.ID(),\n\t\t\tRealmId:               realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm that this LDAP mapper will exist in.\n- `ldap_user_federation_id` - (Required) The ID of the LDAP user federation provider to attach this mapper to.\n- `name` - (Required) Display name of this mapper when displayed in the console.\n- `ldap_full_name_attribute` - (Required) The name of the LDAP attribute containing the user's full name.\n- `read_only` - (Optional) When `true`, updates to a user within Keycloak will not be written back to LDAP. Defaults to `false`.\n- `write_only` - (Optional) When `true`, this mapper will only be used to write updates to LDAP. Defaults to `false`.\n",
            "properties": {
                "ldapFullNameAttribute": {
                    "type": "string"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "readOnly": {
                    "type": "boolean"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                },
                "writeOnly": {
                    "type": "boolean"
                }
            },
            "required": [
                "ldapFullNameAttribute",
                "ldapUserFederationId",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "ldapFullNameAttribute": {
                    "type": "string"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "readOnly": {
                    "type": "boolean"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                },
                "writeOnly": {
                    "type": "boolean"
                }
            },
            "requiredInputs": [
                "ldapFullNameAttribute",
                "ldapUserFederationId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FullNameMapper resources.\n",
                "properties": {
                    "ldapFullNameAttribute": {
                        "type": "string"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ldap user federation provider to attach this mapper to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the mapper when displayed in the console.\n"
                    },
                    "readOnly": {
                        "type": "boolean"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm in which the ldap user federation provider exists.\n"
                    },
                    "writeOnly": {
                        "type": "boolean"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/groupMapper:GroupMapper": {
            "description": "## # keycloak.ldap.GroupMapper\n\nAllows for creating and managing group mappers for Keycloak users federated\nvia LDAP.\n\nThe LDAP group mapper can be used to map an LDAP user's groups from some DN\nto Keycloak groups. This group mapper will also create the groups within Keycloak\nif they do not already exist.\n\n### Example Usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"test\",\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldap_user_federation\", {\n    bindCredential: \"admin\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    connectionUrl: \"ldap://openldap\",\n    rdnLdapAttribute: \"cn\",\n    realmId: realm.id,\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    usernameLdapAttribute: \"cn\",\n    usersDn: \"dc=example,dc=org\",\n    uuidLdapAttribute: \"entryDN\",\n});\nconst ldapGroupMapper = new keycloak.ldap.GroupMapper(\"ldap_group_mapper\", {\n    groupNameLdapAttribute: \"cn\",\n    groupObjectClasses: [\"groupOfNames\"],\n    ldapGroupsDn: \"dc=example,dc=org\",\n    ldapUserFederationId: ldapUserFederation.id,\n    memberofLdapAttribute: \"memberOf\",\n    membershipAttributeType: \"DN\",\n    membershipLdapAttribute: \"member\",\n    membershipUserLdapAttribute: \"cn\",\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"test\")\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    bind_credential=\"admin\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    connection_url=\"ldap://openldap\",\n    rdn_ldap_attribute=\"cn\",\n    realm_id=realm.id,\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    username_ldap_attribute=\"cn\",\n    users_dn=\"dc=example,dc=org\",\n    uuid_ldap_attribute=\"entryDN\")\nldap_group_mapper = keycloak.ldap.GroupMapper(\"ldapGroupMapper\",\n    group_name_ldap_attribute=\"cn\",\n    group_object_classes=[\"groupOfNames\"],\n    ldap_groups_dn=\"dc=example,dc=org\",\n    ldap_user_federation_id=ldap_user_federation.id,\n    memberof_ldap_attribute=\"memberOf\",\n    membership_attribute_type=\"DN\",\n    membership_ldap_attribute=\"member\",\n    membership_user_ldap_attribute=\"cn\",\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"test\",\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            BindCredential = \"admin\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            ConnectionUrl = \"ldap://openldap\",\n            RdnLdapAttribute = \"cn\",\n            RealmId = realm.Id,\n            UserObjectClasses = \n            {\n                \"simpleSecurityObject\",\n                \"organizationalRole\",\n            },\n            UsernameLdapAttribute = \"cn\",\n            UsersDn = \"dc=example,dc=org\",\n            UuidLdapAttribute = \"entryDN\",\n        });\n        var ldapGroupMapper = new Keycloak.Ldap.GroupMapper(\"ldapGroupMapper\", new Keycloak.Ldap.GroupMapperArgs\n        {\n            GroupNameLdapAttribute = \"cn\",\n            GroupObjectClasses = \n            {\n                \"groupOfNames\",\n            },\n            LdapGroupsDn = \"dc=example,dc=org\",\n            LdapUserFederationId = ldapUserFederation.Id,\n            MemberofLdapAttribute = \"memberOf\",\n            MembershipAttributeType = \"DN\",\n            MembershipLdapAttribute = \"member\",\n            MembershipUserLdapAttribute = \"cn\",\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tBindCredential:   pulumi.String(\"admin\"),\n\t\t\tBindDn:           pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tConnectionUrl:    pulumi.String(\"ldap://openldap\"),\n\t\t\tRdnLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRealmId:          realm.ID(),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tUsersDn:               pulumi.String(\"dc=example,dc=org\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewGroupMapper(ctx, \"ldapGroupMapper\", \u0026ldap.GroupMapperArgs{\n\t\t\tGroupNameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tGroupObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"groupOfNames\"),\n\t\t\t},\n\t\t\tLdapGroupsDn:                pulumi.String(\"dc=example,dc=org\"),\n\t\t\tLdapUserFederationId:        ldapUserFederation.ID(),\n\t\t\tMemberofLdapAttribute:       pulumi.String(\"memberOf\"),\n\t\t\tMembershipAttributeType:     pulumi.String(\"DN\"),\n\t\t\tMembershipLdapAttribute:     pulumi.String(\"member\"),\n\t\t\tMembershipUserLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRealmId:                     realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm that this LDAP mapper will exist in.\n- `ldap_user_federation_id` - (Required) The ID of the LDAP user federation provider to attach this mapper to.\n- `name` - (Required) Display name of this mapper when displayed in the console.\n- `ldap_groups_dn` - (Required) The LDAP DN where groups can be found.\n- `group_name_ldap_attribute` - (Required) The name of the LDAP attribute that is used in group objects for the name and RDN of the group. Typically `cn`.\n- `group_object_classes` - (Required) Array of strings representing the object classes for the group. Must contain at least one.\n- `preserve_group_inheritance` - (Optional) When `true`, group inheritance will be propagated from LDAP to Keycloak. When `false`, all LDAP groups will be propagated as top level groups within Keycloak.\n- `ignore_missing_groups` - (Optional) When `true`, missing groups in the hierarchy will be ignored.\n- `membership_ldap_attribute` - (Required) The name of the LDAP attribute that is used for membership mappings.\n- `membership_attribute_type` - (Optional) Can be one of `DN` or `UID`. Defaults to `DN`.\n- `membership_user_ldap_attribute` - (Required) The name of the LDAP attribute on a user that is used for membership mappings.\n- `groups_ldap_filter` - (Optional) When specified, adds an additional custom filter to be used when querying for groups. Must start with `(` and end with `)`.\n- `mode` - (Optional) Can be one of `READ_ONLY` or `LDAP_ONLY`. Defaults to `READ_ONLY`.\n- `user_roles_retrieve_strategy` - (Optional) Can be one of `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE`, `GET_GROUPS_FROM_USER_MEMBEROF_ATTRIBUTE`, or `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE_RECURSIVELY`. Defaults to `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE`.\n- `memberof_ldap_attribute` - (Optional) Specifies the name of the LDAP attribute on the LDAP user that contains the groups the user is a member of. Defaults to `memberOf`.\n- `mapped_group_attributes` - (Optional) Array of strings representing attributes on the LDAP group which will be mapped to attributes on the Keycloak group.\n- `drop_non_existing_groups_during_sync` - (Optional) When `true`, groups that no longer exist within LDAP will be dropped in Keycloak during sync. Defaults to `false`.\n",
            "properties": {
                "dropNonExistingGroupsDuringSync": {
                    "type": "boolean"
                },
                "groupNameLdapAttribute": {
                    "type": "string"
                },
                "groupObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "groupsLdapFilter": {
                    "type": "string"
                },
                "ignoreMissingGroups": {
                    "type": "boolean"
                },
                "ldapGroupsDn": {
                    "type": "string"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "mappedGroupAttributes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "memberofLdapAttribute": {
                    "type": "string"
                },
                "membershipAttributeType": {
                    "type": "string"
                },
                "membershipLdapAttribute": {
                    "type": "string"
                },
                "membershipUserLdapAttribute": {
                    "type": "string"
                },
                "mode": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "preserveGroupInheritance": {
                    "type": "boolean"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                },
                "userRolesRetrieveStrategy": {
                    "type": "string"
                }
            },
            "required": [
                "groupNameLdapAttribute",
                "groupObjectClasses",
                "ldapGroupsDn",
                "ldapUserFederationId",
                "membershipLdapAttribute",
                "membershipUserLdapAttribute",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "dropNonExistingGroupsDuringSync": {
                    "type": "boolean"
                },
                "groupNameLdapAttribute": {
                    "type": "string"
                },
                "groupObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "groupsLdapFilter": {
                    "type": "string"
                },
                "ignoreMissingGroups": {
                    "type": "boolean"
                },
                "ldapGroupsDn": {
                    "type": "string"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "mappedGroupAttributes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "memberofLdapAttribute": {
                    "type": "string"
                },
                "membershipAttributeType": {
                    "type": "string"
                },
                "membershipLdapAttribute": {
                    "type": "string"
                },
                "membershipUserLdapAttribute": {
                    "type": "string"
                },
                "mode": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "preserveGroupInheritance": {
                    "type": "boolean"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                },
                "userRolesRetrieveStrategy": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "groupNameLdapAttribute",
                "groupObjectClasses",
                "ldapGroupsDn",
                "ldapUserFederationId",
                "membershipLdapAttribute",
                "membershipUserLdapAttribute",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupMapper resources.\n",
                "properties": {
                    "dropNonExistingGroupsDuringSync": {
                        "type": "boolean"
                    },
                    "groupNameLdapAttribute": {
                        "type": "string"
                    },
                    "groupObjectClasses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "groupsLdapFilter": {
                        "type": "string"
                    },
                    "ignoreMissingGroups": {
                        "type": "boolean"
                    },
                    "ldapGroupsDn": {
                        "type": "string"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ldap user federation provider to attach this mapper to.\n"
                    },
                    "mappedGroupAttributes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "memberofLdapAttribute": {
                        "type": "string"
                    },
                    "membershipAttributeType": {
                        "type": "string"
                    },
                    "membershipLdapAttribute": {
                        "type": "string"
                    },
                    "membershipUserLdapAttribute": {
                        "type": "string"
                    },
                    "mode": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the mapper when displayed in the console.\n"
                    },
                    "preserveGroupInheritance": {
                        "type": "boolean"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm in which the ldap user federation provider exists.\n"
                    },
                    "userRolesRetrieveStrategy": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/hardcodedGroupMapper:HardcodedGroupMapper": {
            "properties": {
                "group": {
                    "type": "string",
                    "description": "Group to grant to user.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                }
            },
            "required": [
                "group",
                "ldapUserFederationId",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "group": {
                    "type": "string",
                    "description": "Group to grant to user.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                }
            },
            "requiredInputs": [
                "group",
                "ldapUserFederationId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedGroupMapper resources.\n",
                "properties": {
                    "group": {
                        "type": "string",
                        "description": "Group to grant to user.\n"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ldap user federation provider to attach this mapper to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the mapper when displayed in the console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm in which the ldap user federation provider exists.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/hardcodedRoleMapper:HardcodedRoleMapper": {
            "description": "## # keycloak.ldap.HardcodedRoleMapper\n\nThis mapper will grant a specified Keycloak role to each Keycloak user linked with LDAP.\n\n### Example Usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"test\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldapUserFederation\", {\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst assignAdminRoleToAllUsers = new keycloak.ldap.HardcodedRoleMapper(\"assignAdminRoleToAllUsers\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n    role: \"admin\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"test\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nassign_admin_role_to_all_users = keycloak.ldap.HardcodedRoleMapper(\"assignAdminRoleToAllUsers\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id,\n    role=\"admin\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"test\",\n            Enabled = true,\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            RealmId = realm.Id,\n            UsernameLdapAttribute = \"cn\",\n            RdnLdapAttribute = \"cn\",\n            UuidLdapAttribute = \"entryDN\",\n            UserObjectClasses = \n            {\n                \"simpleSecurityObject\",\n                \"organizationalRole\",\n            },\n            ConnectionUrl = \"ldap://openldap\",\n            UsersDn = \"dc=example,dc=org\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            BindCredential = \"admin\",\n        });\n        var assignAdminRoleToAllUsers = new Keycloak.Ldap.HardcodedRoleMapper(\"assignAdminRoleToAllUsers\", new Keycloak.Ldap.HardcodedRoleMapperArgs\n        {\n            RealmId = realm.Id,\n            LdapUserFederationId = ldapUserFederation.Id,\n            Role = \"admin\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"test\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewHardcodedRoleMapper(ctx, \"assignAdminRoleToAllUsers\", \u0026ldap.HardcodedRoleMapperArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tLdapUserFederationId: ldapUserFederation.ID(),\n\t\t\tRole:                 pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm that this LDAP mapper will exist in.\n- `ldap_user_federation_id` - (Required) The ID of the LDAP user federation provider to attach this mapper to.\n- `name` - (Required) Display name of this mapper when displayed in the console.\n- `role` - (Required) The role which should be assigned to the users.\n",
            "properties": {
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role to grant to user.\n"
                }
            },
            "required": [
                "ldapUserFederationId",
                "name",
                "realmId",
                "role"
            ],
            "inputProperties": {
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role to grant to user.\n"
                }
            },
            "requiredInputs": [
                "ldapUserFederationId",
                "realmId",
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedRoleMapper resources.\n",
                "properties": {
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ldap user federation provider to attach this mapper to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the mapper when displayed in the console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm in which the ldap user federation provider exists.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "Role to grant to user.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/msadLdsUserAccountControlMapper:MsadLdsUserAccountControlMapper": {
            "description": "## # keycloak.ldap.MsadLdsUserAccountControlMapper\n\nAllows for creating and managing MSAD-LDS user account control mappers for Keycloak\nusers federated via LDAP.\n\nThe MSAD-LDS (Microsoft Active Directory Lightweight Directory Service) user account control mapper is specific\nto LDAP user federation providers that are pulling from AD-LDS, and it can propagate\nAD-LDS user state to Keycloak in order to enforce settings like expired passwords\nor disabled accounts.\n\n### Example Usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"test\",\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldap_user_federation\", {\n    bindCredential: \"admin\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    connectionUrl: \"ldap://my-ad-server\",\n    rdnLdapAttribute: \"cn\",\n    realmId: realm.id,\n    userObjectClasses: [\n        \"person\",\n        \"organizationalPerson\",\n        \"user\",\n    ],\n    usernameLdapAttribute: \"cn\",\n    usersDn: \"dc=example,dc=org\",\n    uuidLdapAttribute: \"objectGUID\",\n});\nconst msadLdsUserAccountControlMapper = new keycloak.ldap.MsadLdsUserAccountControlMapper(\"msad_lds_user_account_control_mapper\", {\n    ldapUserFederationId: ldapUserFederation.id,\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"test\")\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    bind_credential=\"admin\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    connection_url=\"ldap://my-ad-server\",\n    rdn_ldap_attribute=\"cn\",\n    realm_id=realm.id,\n    user_object_classes=[\n        \"person\",\n        \"organizationalPerson\",\n        \"user\",\n    ],\n    username_ldap_attribute=\"cn\",\n    users_dn=\"dc=example,dc=org\",\n    uuid_ldap_attribute=\"objectGUID\")\nmsad_lds_user_account_control_mapper = keycloak.ldap.MsadLdsUserAccountControlMapper(\"msadLdsUserAccountControlMapper\",\n    ldap_user_federation_id=ldap_user_federation.id,\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"test\",\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            BindCredential = \"admin\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            ConnectionUrl = \"ldap://my-ad-server\",\n            RdnLdapAttribute = \"cn\",\n            RealmId = realm.Id,\n            UserObjectClasses = \n            {\n                \"person\",\n                \"organizationalPerson\",\n                \"user\",\n            },\n            UsernameLdapAttribute = \"cn\",\n            UsersDn = \"dc=example,dc=org\",\n            UuidLdapAttribute = \"objectGUID\",\n        });\n        var msadLdsUserAccountControlMapper = new Keycloak.Ldap.MsadLdsUserAccountControlMapper(\"msadLdsUserAccountControlMapper\", new Keycloak.Ldap.MsadLdsUserAccountControlMapperArgs\n        {\n            LdapUserFederationId = ldapUserFederation.Id,\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tBindCredential:   pulumi.String(\"admin\"),\n\t\t\tBindDn:           pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tConnectionUrl:    pulumi.String(\"ldap://my-ad-server\"),\n\t\t\tRdnLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRealmId:          realm.ID(),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"person\"),\n\t\t\t\tpulumi.String(\"organizationalPerson\"),\n\t\t\t\tpulumi.String(\"user\"),\n\t\t\t},\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tUsersDn:               pulumi.String(\"dc=example,dc=org\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"objectGUID\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewMsadLdsUserAccountControlMapper(ctx, \"msadLdsUserAccountControlMapper\", \u0026ldap.MsadLdsUserAccountControlMapperArgs{\n\t\t\tLdapUserFederationId: ldapUserFederation.ID(),\n\t\t\tRealmId:              realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm that this LDAP mapper will exist in.\n- `ldap_user_federation_id` - (Required) The ID of the LDAP user federation provider to attach this mapper to.\n- `name` - (Required) Display name of this mapper when displayed in the console.\n",
            "properties": {
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                }
            },
            "required": [
                "ldapUserFederationId",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                }
            },
            "requiredInputs": [
                "ldapUserFederationId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MsadLdsUserAccountControlMapper resources.\n",
                "properties": {
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ldap user federation provider to attach this mapper to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the mapper when displayed in the console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm in which the ldap user federation provider exists.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/msadUserAccountControlMapper:MsadUserAccountControlMapper": {
            "description": "## # keycloak.ldap.MsadUserAccountControlMapper\n\nAllows for creating and managing MSAD user account control mappers for Keycloak\nusers federated via LDAP.\n\nThe MSAD (Microsoft Active Directory) user account control mapper is specific\nto LDAP user federation providers that are pulling from AD, and it can propagate\nAD user state to Keycloak in order to enforce settings like expired passwords\nor disabled accounts.\n\n### Example Usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"test\",\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldap_user_federation\", {\n    bindCredential: \"admin\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    connectionUrl: \"ldap://my-ad-server\",\n    rdnLdapAttribute: \"cn\",\n    realmId: realm.id,\n    userObjectClasses: [\n        \"person\",\n        \"organizationalPerson\",\n        \"user\",\n    ],\n    usernameLdapAttribute: \"cn\",\n    usersDn: \"dc=example,dc=org\",\n    uuidLdapAttribute: \"objectGUID\",\n});\nconst msadUserAccountControlMapper = new keycloak.ldap.MsadUserAccountControlMapper(\"msad_user_account_control_mapper\", {\n    ldapUserFederationId: ldapUserFederation.id,\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"test\")\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    bind_credential=\"admin\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    connection_url=\"ldap://my-ad-server\",\n    rdn_ldap_attribute=\"cn\",\n    realm_id=realm.id,\n    user_object_classes=[\n        \"person\",\n        \"organizationalPerson\",\n        \"user\",\n    ],\n    username_ldap_attribute=\"cn\",\n    users_dn=\"dc=example,dc=org\",\n    uuid_ldap_attribute=\"objectGUID\")\nmsad_user_account_control_mapper = keycloak.ldap.MsadUserAccountControlMapper(\"msadUserAccountControlMapper\",\n    ldap_user_federation_id=ldap_user_federation.id,\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"test\",\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            BindCredential = \"admin\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            ConnectionUrl = \"ldap://my-ad-server\",\n            RdnLdapAttribute = \"cn\",\n            RealmId = realm.Id,\n            UserObjectClasses = \n            {\n                \"person\",\n                \"organizationalPerson\",\n                \"user\",\n            },\n            UsernameLdapAttribute = \"cn\",\n            UsersDn = \"dc=example,dc=org\",\n            UuidLdapAttribute = \"objectGUID\",\n        });\n        var msadUserAccountControlMapper = new Keycloak.Ldap.MsadUserAccountControlMapper(\"msadUserAccountControlMapper\", new Keycloak.Ldap.MsadUserAccountControlMapperArgs\n        {\n            LdapUserFederationId = ldapUserFederation.Id,\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tBindCredential:   pulumi.String(\"admin\"),\n\t\t\tBindDn:           pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tConnectionUrl:    pulumi.String(\"ldap://my-ad-server\"),\n\t\t\tRdnLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRealmId:          realm.ID(),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"person\"),\n\t\t\t\tpulumi.String(\"organizationalPerson\"),\n\t\t\t\tpulumi.String(\"user\"),\n\t\t\t},\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tUsersDn:               pulumi.String(\"dc=example,dc=org\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"objectGUID\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewMsadUserAccountControlMapper(ctx, \"msadUserAccountControlMapper\", \u0026ldap.MsadUserAccountControlMapperArgs{\n\t\t\tLdapUserFederationId: ldapUserFederation.ID(),\n\t\t\tRealmId:              realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm that this LDAP mapper will exist in.\n- `ldap_user_federation_id` - (Required) The ID of the LDAP user federation provider to attach this mapper to.\n- `name` - (Required) Display name of this mapper when displayed in the console.\n- `ldap_password_policy_hints_enabled` - (Optional) When `true`, advanced password policies, such as password hints and previous password history will be used when writing new passwords to AD. Defaults to `false`.\n",
            "properties": {
                "ldapPasswordPolicyHintsEnabled": {
                    "type": "boolean"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                }
            },
            "required": [
                "ldapUserFederationId",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "ldapPasswordPolicyHintsEnabled": {
                    "type": "boolean"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                }
            },
            "requiredInputs": [
                "ldapUserFederationId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MsadUserAccountControlMapper resources.\n",
                "properties": {
                    "ldapPasswordPolicyHintsEnabled": {
                        "type": "boolean"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ldap user federation provider to attach this mapper to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the mapper when displayed in the console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm in which the ldap user federation provider exists.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/roleMapper:RoleMapper": {
            "properties": {
                "clientId": {
                    "type": "string"
                },
                "ldapRolesDn": {
                    "type": "string"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "memberofLdapAttribute": {
                    "type": "string"
                },
                "membershipAttributeType": {
                    "type": "string"
                },
                "membershipLdapAttribute": {
                    "type": "string"
                },
                "membershipUserLdapAttribute": {
                    "type": "string"
                },
                "mode": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                },
                "roleNameLdapAttribute": {
                    "type": "string"
                },
                "roleObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "rolesLdapFilter": {
                    "type": "string"
                },
                "useRealmRolesMapping": {
                    "type": "boolean"
                },
                "userRolesRetrieveStrategy": {
                    "type": "string"
                }
            },
            "required": [
                "ldapRolesDn",
                "ldapUserFederationId",
                "membershipLdapAttribute",
                "membershipUserLdapAttribute",
                "name",
                "realmId",
                "roleNameLdapAttribute",
                "roleObjectClasses"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string"
                },
                "ldapRolesDn": {
                    "type": "string"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "memberofLdapAttribute": {
                    "type": "string"
                },
                "membershipAttributeType": {
                    "type": "string"
                },
                "membershipLdapAttribute": {
                    "type": "string"
                },
                "membershipUserLdapAttribute": {
                    "type": "string"
                },
                "mode": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                },
                "roleNameLdapAttribute": {
                    "type": "string"
                },
                "roleObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "rolesLdapFilter": {
                    "type": "string"
                },
                "useRealmRolesMapping": {
                    "type": "boolean"
                },
                "userRolesRetrieveStrategy": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "ldapRolesDn",
                "ldapUserFederationId",
                "membershipLdapAttribute",
                "membershipUserLdapAttribute",
                "realmId",
                "roleNameLdapAttribute",
                "roleObjectClasses"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RoleMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string"
                    },
                    "ldapRolesDn": {
                        "type": "string"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ldap user federation provider to attach this mapper to.\n"
                    },
                    "memberofLdapAttribute": {
                        "type": "string"
                    },
                    "membershipAttributeType": {
                        "type": "string"
                    },
                    "membershipLdapAttribute": {
                        "type": "string"
                    },
                    "membershipUserLdapAttribute": {
                        "type": "string"
                    },
                    "mode": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the mapper when displayed in the console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm in which the ldap user federation provider exists.\n"
                    },
                    "roleNameLdapAttribute": {
                        "type": "string"
                    },
                    "roleObjectClasses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "rolesLdapFilter": {
                        "type": "string"
                    },
                    "useRealmRolesMapping": {
                        "type": "boolean"
                    },
                    "userRolesRetrieveStrategy": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/userAttributeMapper:UserAttributeMapper": {
            "description": "## # keycloak.ldap.UserAttributeMapper\n\nAllows for creating and managing user attribute mappers for Keycloak users\nfederated via LDAP.\n\nThe LDAP user attribute mapper can be used to map a single LDAP attribute\nto an attribute on the Keycloak user model.\n\n### Example Usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"test\",\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldap_user_federation\", {\n    bindCredential: \"admin\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    connectionUrl: \"ldap://openldap\",\n    rdnLdapAttribute: \"cn\",\n    realmId: realm.id,\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    usernameLdapAttribute: \"cn\",\n    usersDn: \"dc=example,dc=org\",\n    uuidLdapAttribute: \"entryDN\",\n});\nconst ldapUserAttributeMapper = new keycloak.ldap.UserAttributeMapper(\"ldap_user_attribute_mapper\", {\n    ldapAttribute: \"bar\",\n    ldapUserFederationId: ldapUserFederation.id,\n    realmId: realm.id,\n    userModelAttribute: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"test\")\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    bind_credential=\"admin\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    connection_url=\"ldap://openldap\",\n    rdn_ldap_attribute=\"cn\",\n    realm_id=realm.id,\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    username_ldap_attribute=\"cn\",\n    users_dn=\"dc=example,dc=org\",\n    uuid_ldap_attribute=\"entryDN\")\nldap_user_attribute_mapper = keycloak.ldap.UserAttributeMapper(\"ldapUserAttributeMapper\",\n    ldap_attribute=\"bar\",\n    ldap_user_federation_id=ldap_user_federation.id,\n    realm_id=realm.id,\n    user_model_attribute=\"foo\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"test\",\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            BindCredential = \"admin\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            ConnectionUrl = \"ldap://openldap\",\n            RdnLdapAttribute = \"cn\",\n            RealmId = realm.Id,\n            UserObjectClasses = \n            {\n                \"simpleSecurityObject\",\n                \"organizationalRole\",\n            },\n            UsernameLdapAttribute = \"cn\",\n            UsersDn = \"dc=example,dc=org\",\n            UuidLdapAttribute = \"entryDN\",\n        });\n        var ldapUserAttributeMapper = new Keycloak.Ldap.UserAttributeMapper(\"ldapUserAttributeMapper\", new Keycloak.Ldap.UserAttributeMapperArgs\n        {\n            LdapAttribute = \"bar\",\n            LdapUserFederationId = ldapUserFederation.Id,\n            RealmId = realm.Id,\n            UserModelAttribute = \"foo\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tBindCredential:   pulumi.String(\"admin\"),\n\t\t\tBindDn:           pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tConnectionUrl:    pulumi.String(\"ldap://openldap\"),\n\t\t\tRdnLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRealmId:          realm.ID(),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tUsersDn:               pulumi.String(\"dc=example,dc=org\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewUserAttributeMapper(ctx, \"ldapUserAttributeMapper\", \u0026ldap.UserAttributeMapperArgs{\n\t\t\tLdapAttribute:        pulumi.String(\"bar\"),\n\t\t\tLdapUserFederationId: ldapUserFederation.ID(),\n\t\t\tRealmId:              realm.ID(),\n\t\t\tUserModelAttribute:   pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm that this LDAP mapper will exist in.\n- `ldap_user_federation_id` - (Required) The ID of the LDAP user federation provider to attach this mapper to.\n- `name` - (Required) Display name of this mapper when displayed in the console.\n- `user_model_attribute` - (Required) Name of the user property or attribute you want to map the LDAP attribute into.\n- `ldap_attribute` - (Required) Name of the mapped attribute on the LDAP object.\n- `read_only` - (Optional) When `true`, this attribute is not saved back to LDAP when the user attribute is updated in Keycloak. Defaults to `false`.\n- `always_read_value_from_ldap` - (Optional) When `true`, the value fetched from LDAP will override the value stored in Keycloak. Defaults to `false`.\n- `is_mandatory_in_ldap` - (Optional) When `true`, this attribute must exist in LDAP. Defaults to `false`.\n",
            "properties": {
                "alwaysReadValueFromLdap": {
                    "type": "boolean",
                    "description": "When true, the value fetched from LDAP will override the value stored in Keycloak.\n"
                },
                "isMandatoryInLdap": {
                    "type": "boolean",
                    "description": "When true, this attribute must exist in LDAP.\n"
                },
                "ldapAttribute": {
                    "type": "string",
                    "description": "Name of the mapped attribute on LDAP object.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "readOnly": {
                    "type": "boolean",
                    "description": "When true, this attribute is not saved back to LDAP when the user attribute is updated in Keycloak.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                },
                "userModelAttribute": {
                    "type": "string",
                    "description": "Name of the UserModel property or attribute you want to map the LDAP attribute into.\n"
                }
            },
            "required": [
                "ldapAttribute",
                "ldapUserFederationId",
                "name",
                "realmId",
                "userModelAttribute"
            ],
            "inputProperties": {
                "alwaysReadValueFromLdap": {
                    "type": "boolean",
                    "description": "When true, the value fetched from LDAP will override the value stored in Keycloak.\n"
                },
                "isMandatoryInLdap": {
                    "type": "boolean",
                    "description": "When true, this attribute must exist in LDAP.\n"
                },
                "ldapAttribute": {
                    "type": "string",
                    "description": "Name of the mapped attribute on LDAP object.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "readOnly": {
                    "type": "boolean",
                    "description": "When true, this attribute is not saved back to LDAP when the user attribute is updated in Keycloak.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                },
                "userModelAttribute": {
                    "type": "string",
                    "description": "Name of the UserModel property or attribute you want to map the LDAP attribute into.\n"
                }
            },
            "requiredInputs": [
                "ldapAttribute",
                "ldapUserFederationId",
                "realmId",
                "userModelAttribute"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserAttributeMapper resources.\n",
                "properties": {
                    "alwaysReadValueFromLdap": {
                        "type": "boolean",
                        "description": "When true, the value fetched from LDAP will override the value stored in Keycloak.\n"
                    },
                    "isMandatoryInLdap": {
                        "type": "boolean",
                        "description": "When true, this attribute must exist in LDAP.\n"
                    },
                    "ldapAttribute": {
                        "type": "string",
                        "description": "Name of the mapped attribute on LDAP object.\n"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ldap user federation provider to attach this mapper to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the mapper when displayed in the console.\n"
                    },
                    "readOnly": {
                        "type": "boolean",
                        "description": "When true, this attribute is not saved back to LDAP when the user attribute is updated in Keycloak.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm in which the ldap user federation provider exists.\n"
                    },
                    "userModelAttribute": {
                        "type": "string",
                        "description": "Name of the UserModel property or attribute you want to map the LDAP attribute into.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/userFederation:UserFederation": {
            "description": "## # keycloak.ldap.UserFederation\n\nAllows for creating and managing LDAP user federation providers within Keycloak.\n\nKeycloak can use an LDAP user federation provider to federate users to Keycloak\nfrom a directory system such as LDAP or Active Directory. Federated users\nwill exist within the realm and will be able to log in to clients. Federated\nusers can have their attributes defined using mappers.\n\n### Example Usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"test\",\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldap_user_federation\", {\n    bindCredential: \"admin\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    connectionTimeout: \"5s\",\n    connectionUrl: \"ldap://openldap\",\n    enabled: true,\n    kerberos: {\n        kerberosRealm: \"FOO.LOCAL\",\n        keytab: \"/etc/host.keytab\",\n        serverPrincipal: \"HTTP/host.foo.com@FOO.LOCAL\",\n    },\n    rdnLdapAttribute: \"cn\",\n    readTimeout: \"10s\",\n    realmId: realm.id,\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    usernameLdapAttribute: \"cn\",\n    usersDn: \"dc=example,dc=org\",\n    uuidLdapAttribute: \"entryDN\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"test\")\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    bind_credential=\"admin\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    connection_timeout=\"5s\",\n    connection_url=\"ldap://openldap\",\n    enabled=True,\n    kerberos=keycloak.ldap.UserFederationKerberosArgs(\n        kerberos_realm=\"FOO.LOCAL\",\n        keytab=\"/etc/host.keytab\",\n        server_principal=\"HTTP/host.foo.com@FOO.LOCAL\",\n    ),\n    rdn_ldap_attribute=\"cn\",\n    read_timeout=\"10s\",\n    realm_id=realm.id,\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    username_ldap_attribute=\"cn\",\n    users_dn=\"dc=example,dc=org\",\n    uuid_ldap_attribute=\"entryDN\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"test\",\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            BindCredential = \"admin\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            ConnectionTimeout = \"5s\",\n            ConnectionUrl = \"ldap://openldap\",\n            Enabled = true,\n            Kerberos = new Keycloak.Ldap.Inputs.UserFederationKerberosArgs\n            {\n                KerberosRealm = \"FOO.LOCAL\",\n                Keytab = \"/etc/host.keytab\",\n                ServerPrincipal = \"HTTP/host.foo.com@FOO.LOCAL\",\n            },\n            RdnLdapAttribute = \"cn\",\n            ReadTimeout = \"10s\",\n            RealmId = realm.Id,\n            UserObjectClasses = \n            {\n                \"simpleSecurityObject\",\n                \"organizationalRole\",\n            },\n            UsernameLdapAttribute = \"cn\",\n            UsersDn = \"dc=example,dc=org\",\n            UuidLdapAttribute = \"entryDN\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tBindCredential:    pulumi.String(\"admin\"),\n\t\t\tBindDn:            pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tConnectionTimeout: pulumi.String(\"5s\"),\n\t\t\tConnectionUrl:     pulumi.String(\"ldap://openldap\"),\n\t\t\tEnabled:           pulumi.Bool(true),\n\t\t\tKerberos: \u0026ldap.UserFederationKerberosArgs{\n\t\t\t\tKerberosRealm:   pulumi.String(\"FOO.LOCAL\"),\n\t\t\t\tKeytab:          pulumi.String(\"/etc/host.keytab\"),\n\t\t\t\tServerPrincipal: pulumi.String(\"HTTP/host.foo.com@FOO.LOCAL\"),\n\t\t\t},\n\t\t\tRdnLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tReadTimeout:      pulumi.String(\"10s\"),\n\t\t\tRealmId:          realm.ID(),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tUsersDn:               pulumi.String(\"dc=example,dc=org\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm that this provider will provide user federation for.\n- `name` - (Required) Display name of the provider when displayed in the console.\n- `enabled` - (Optional) When `false`, this provider will not be used when performing queries for users. Defaults to `true`.\n- `priority` - (Optional) Priority of this provider when looking up users. Lower values are first. Defaults to `0`.\n- `import_enabled` - (Optional) When `true`, LDAP users will be imported into the Keycloak database. Defaults to `true`.\n- `edit_mode` - (Optional) Can be one of `READ_ONLY`, `WRITABLE`, or `UNSYNCED`. `UNSYNCED` allows user data to be imported but not synced back to LDAP. Defaults to `READ_ONLY`.\n- `sync_registrations` - (Optional) When `true`, newly created users will be synced back to LDAP. Defaults to `false`.\n- `vendor` - (Optional) Can be one of `OTHER`, `EDIRECTORY`, `AD`, `RHDS`, or `TIVOLI`. When this is selected in the GUI, it provides reasonable defaults for other fields. When used with the Keycloak API, this attribute does nothing, but is still required. Defaults to `OTHER`.\n- `username_ldap_attribute` - (Required) Name of the LDAP attribute to use as the Keycloak username.\n- `rdn_ldap_attribute` - (Required) Name of the LDAP attribute to use as the relative distinguished name.\n- `uuid_ldap_attribute` - (Required) Name of the LDAP attribute to use as a unique object identifier for objects in LDAP.\n- `user_object_classes` - (Required) Array of all values of LDAP objectClass attribute for users in LDAP. Must contain at least one.\n- `connection_url` - (Required) Connection URL to the LDAP server.\n- `users_dn` - (Required) Full DN of LDAP tree where your users are.\n- `bind_dn` - (Optional) DN of LDAP admin, which will be used by Keycloak to access LDAP server. This attribute must be set if `bind_credential` is set.\n- `bind_credential` - (Optional) Password of LDAP admin. This attribute must be set if `bind_dn` is set.\n- `custom_user_search_filter` - (Optional) Additional LDAP filter for filtering searched users. Must begin with `(` and end with `)`.\n- `search_scope` - (Optional) Can be one of `ONE_LEVEL` or `SUBTREE`:\n    - `ONE_LEVEL`: Only search for users in the DN specified by `user_dn`.\n    - `SUBTREE`: Search entire LDAP subtree.\n- `validate_password_policy` - (Optional) When `true`, Keycloak will validate passwords using the realm policy before updating it.\n- `use_truststore_spi` - (Optional) Can be one of `ALWAYS`, `ONLY_FOR_LDAPS`, or `NEVER`:\n    - `ALWAYS` - Always use the truststore SPI for LDAP connections.\n    - `NEVER` - Never use the truststore SPI for LDAP connections.\n    - `ONLY_FOR_LDAPS` - Only use the truststore SPI if your LDAP connection uses the ldaps protocol.\n- `connection_timeout` - (Optional) LDAP connection timeout in the format of a [Go duration string](https://golang.org/pkg/time/#Duration.String).\n- `read_timeout` - (Optional) LDAP read timeout in the format of a [Go duration string](https://golang.org/pkg/time/#Duration.String).\n- `pagination` - (Optional) When true, Keycloak assumes the LDAP server supports pagination. Defaults to `true`.\n- `batch_size_for_sync` - (Optional) The number of users to sync within a single transaction. Defaults to `1000`.\n- `full_sync_period` - (Optional) How frequently Keycloak should sync all LDAP users, in seconds. Omit this property to disable periodic full sync.\n- `changed_sync_period` - (Optional) How frequently Keycloak should sync changed LDAP users, in seconds. Omit this property to disable periodic changed users sync.\n- `cache_policy` - (Optional) Can be one of `DEFAULT`, `EVICT_DAILY`, `EVICT_WEEKLY`, `MAX_LIFESPAN`, or `NO_CACHE`. Defaults to `DEFAULT`.\n- `kerberos` - (Optional) A block containing the kerberos settings.\n  - `kerberos_realm` - (Required) The name of the kerberos realm, e.g. FOO.LOCAL.\n  - `server_principal` - (Required) The kerberos server principal, e.g. 'HTTP/host.foo.com@FOO.LOCAL'.\n  - `key_tab` - (Required) Path to the kerberos keytab file on the server with credentials of the service principal.\n  - `use_kerberos_for_password_authentication` - (Optional) Use kerberos login module instead of ldap service api. Defaults to `false`.\n",
            "properties": {
                "batchSizeForSync": {
                    "type": "integer",
                    "description": "The number of users to sync within a single transaction.\n"
                },
                "bindCredential": {
                    "type": "string",
                    "description": "Password of LDAP admin.\n"
                },
                "bindDn": {
                    "type": "string",
                    "description": "DN of LDAP admin, which will be used by Keycloak to access LDAP server.\n"
                },
                "cachePolicy": {
                    "type": "string"
                },
                "changedSyncPeriod": {
                    "type": "integer",
                    "description": "How frequently Keycloak should sync changed LDAP users, in seconds. Omit this property to disable periodic changed users\nsync.\n"
                },
                "connectionTimeout": {
                    "type": "string",
                    "description": "LDAP connection timeout (duration string)\n"
                },
                "connectionUrl": {
                    "type": "string",
                    "description": "Connection URL to the LDAP server.\n"
                },
                "customUserSearchFilter": {
                    "type": "string",
                    "description": "Additional LDAP filter for filtering searched users. Must begin with '(' and end with ')'.\n"
                },
                "editMode": {
                    "type": "string",
                    "description": "READ_ONLY and WRITABLE are self-explanatory. UNSYNCED allows user data to be imported but not synced back to LDAP.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When false, this provider will not be used when performing queries for users.\n"
                },
                "fullSyncPeriod": {
                    "type": "integer",
                    "description": "How frequently Keycloak should sync all LDAP users, in seconds. Omit this property to disable periodic full sync.\n"
                },
                "importEnabled": {
                    "type": "boolean",
                    "description": "When true, LDAP users will be imported into the Keycloak database.\n"
                },
                "kerberos": {
                    "$ref": "#/types/keycloak:ldap/UserFederationKerberos:UserFederationKerberos",
                    "description": "Settings regarding kerberos authentication for this realm.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the provider when displayed in the console.\n"
                },
                "pagination": {
                    "type": "boolean",
                    "description": "When true, Keycloak assumes the LDAP server supports pagination.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of this provider when looking up users. Lower values are first.\n"
                },
                "rdnLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as the relative distinguished name.\n"
                },
                "readTimeout": {
                    "type": "string",
                    "description": "LDAP read timeout (duration string)\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this provider will provide user federation for.\n"
                },
                "searchScope": {
                    "type": "string",
                    "description": "ONE_LEVEL: only search for users in the DN specified by user_dn. SUBTREE: search entire LDAP subtree.\n"
                },
                "syncRegistrations": {
                    "type": "boolean",
                    "description": "When true, newly created users will be synced back to LDAP.\n"
                },
                "useTruststoreSpi": {
                    "type": "string"
                },
                "userObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "All values of LDAP objectClass attribute for users in LDAP.\n"
                },
                "usernameLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as the Keycloak username.\n"
                },
                "usersDn": {
                    "type": "string",
                    "description": "Full DN of LDAP tree where your users are.\n"
                },
                "uuidLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as a unique object identifier for objects in LDAP.\n"
                },
                "validatePasswordPolicy": {
                    "type": "boolean",
                    "description": "When true, Keycloak will validate passwords using the realm policy before updating it.\n"
                },
                "vendor": {
                    "type": "string",
                    "description": "LDAP vendor. I am almost certain this field does nothing, but the UI indicates that it is required.\n"
                }
            },
            "required": [
                "connectionUrl",
                "name",
                "rdnLdapAttribute",
                "realmId",
                "userObjectClasses",
                "usernameLdapAttribute",
                "usersDn",
                "uuidLdapAttribute"
            ],
            "inputProperties": {
                "batchSizeForSync": {
                    "type": "integer",
                    "description": "The number of users to sync within a single transaction.\n"
                },
                "bindCredential": {
                    "type": "string",
                    "description": "Password of LDAP admin.\n"
                },
                "bindDn": {
                    "type": "string",
                    "description": "DN of LDAP admin, which will be used by Keycloak to access LDAP server.\n"
                },
                "cachePolicy": {
                    "type": "string"
                },
                "changedSyncPeriod": {
                    "type": "integer",
                    "description": "How frequently Keycloak should sync changed LDAP users, in seconds. Omit this property to disable periodic changed users\nsync.\n"
                },
                "connectionTimeout": {
                    "type": "string",
                    "description": "LDAP connection timeout (duration string)\n"
                },
                "connectionUrl": {
                    "type": "string",
                    "description": "Connection URL to the LDAP server.\n"
                },
                "customUserSearchFilter": {
                    "type": "string",
                    "description": "Additional LDAP filter for filtering searched users. Must begin with '(' and end with ')'.\n"
                },
                "editMode": {
                    "type": "string",
                    "description": "READ_ONLY and WRITABLE are self-explanatory. UNSYNCED allows user data to be imported but not synced back to LDAP.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When false, this provider will not be used when performing queries for users.\n"
                },
                "fullSyncPeriod": {
                    "type": "integer",
                    "description": "How frequently Keycloak should sync all LDAP users, in seconds. Omit this property to disable periodic full sync.\n"
                },
                "importEnabled": {
                    "type": "boolean",
                    "description": "When true, LDAP users will be imported into the Keycloak database.\n"
                },
                "kerberos": {
                    "$ref": "#/types/keycloak:ldap/UserFederationKerberos:UserFederationKerberos",
                    "description": "Settings regarding kerberos authentication for this realm.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the provider when displayed in the console.\n"
                },
                "pagination": {
                    "type": "boolean",
                    "description": "When true, Keycloak assumes the LDAP server supports pagination.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of this provider when looking up users. Lower values are first.\n"
                },
                "rdnLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as the relative distinguished name.\n"
                },
                "readTimeout": {
                    "type": "string",
                    "description": "LDAP read timeout (duration string)\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this provider will provide user federation for.\n"
                },
                "searchScope": {
                    "type": "string",
                    "description": "ONE_LEVEL: only search for users in the DN specified by user_dn. SUBTREE: search entire LDAP subtree.\n"
                },
                "syncRegistrations": {
                    "type": "boolean",
                    "description": "When true, newly created users will be synced back to LDAP.\n"
                },
                "useTruststoreSpi": {
                    "type": "string"
                },
                "userObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "All values of LDAP objectClass attribute for users in LDAP.\n"
                },
                "usernameLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as the Keycloak username.\n"
                },
                "usersDn": {
                    "type": "string",
                    "description": "Full DN of LDAP tree where your users are.\n"
                },
                "uuidLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as a unique object identifier for objects in LDAP.\n"
                },
                "validatePasswordPolicy": {
                    "type": "boolean",
                    "description": "When true, Keycloak will validate passwords using the realm policy before updating it.\n"
                },
                "vendor": {
                    "type": "string",
                    "description": "LDAP vendor. I am almost certain this field does nothing, but the UI indicates that it is required.\n"
                }
            },
            "requiredInputs": [
                "connectionUrl",
                "rdnLdapAttribute",
                "realmId",
                "userObjectClasses",
                "usernameLdapAttribute",
                "usersDn",
                "uuidLdapAttribute"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserFederation resources.\n",
                "properties": {
                    "batchSizeForSync": {
                        "type": "integer",
                        "description": "The number of users to sync within a single transaction.\n"
                    },
                    "bindCredential": {
                        "type": "string",
                        "description": "Password of LDAP admin.\n"
                    },
                    "bindDn": {
                        "type": "string",
                        "description": "DN of LDAP admin, which will be used by Keycloak to access LDAP server.\n"
                    },
                    "cachePolicy": {
                        "type": "string"
                    },
                    "changedSyncPeriod": {
                        "type": "integer",
                        "description": "How frequently Keycloak should sync changed LDAP users, in seconds. Omit this property to disable periodic changed users\nsync.\n"
                    },
                    "connectionTimeout": {
                        "type": "string",
                        "description": "LDAP connection timeout (duration string)\n"
                    },
                    "connectionUrl": {
                        "type": "string",
                        "description": "Connection URL to the LDAP server.\n"
                    },
                    "customUserSearchFilter": {
                        "type": "string",
                        "description": "Additional LDAP filter for filtering searched users. Must begin with '(' and end with ')'.\n"
                    },
                    "editMode": {
                        "type": "string",
                        "description": "READ_ONLY and WRITABLE are self-explanatory. UNSYNCED allows user data to be imported but not synced back to LDAP.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When false, this provider will not be used when performing queries for users.\n"
                    },
                    "fullSyncPeriod": {
                        "type": "integer",
                        "description": "How frequently Keycloak should sync all LDAP users, in seconds. Omit this property to disable periodic full sync.\n"
                    },
                    "importEnabled": {
                        "type": "boolean",
                        "description": "When true, LDAP users will be imported into the Keycloak database.\n"
                    },
                    "kerberos": {
                        "$ref": "#/types/keycloak:ldap/UserFederationKerberos:UserFederationKerberos",
                        "description": "Settings regarding kerberos authentication for this realm.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the provider when displayed in the console.\n"
                    },
                    "pagination": {
                        "type": "boolean",
                        "description": "When true, Keycloak assumes the LDAP server supports pagination.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority of this provider when looking up users. Lower values are first.\n"
                    },
                    "rdnLdapAttribute": {
                        "type": "string",
                        "description": "Name of the LDAP attribute to use as the relative distinguished name.\n"
                    },
                    "readTimeout": {
                        "type": "string",
                        "description": "LDAP read timeout (duration string)\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this provider will provide user federation for.\n"
                    },
                    "searchScope": {
                        "type": "string",
                        "description": "ONE_LEVEL: only search for users in the DN specified by user_dn. SUBTREE: search entire LDAP subtree.\n"
                    },
                    "syncRegistrations": {
                        "type": "boolean",
                        "description": "When true, newly created users will be synced back to LDAP.\n"
                    },
                    "useTruststoreSpi": {
                        "type": "string"
                    },
                    "userObjectClasses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "All values of LDAP objectClass attribute for users in LDAP.\n"
                    },
                    "usernameLdapAttribute": {
                        "type": "string",
                        "description": "Name of the LDAP attribute to use as the Keycloak username.\n"
                    },
                    "usersDn": {
                        "type": "string",
                        "description": "Full DN of LDAP tree where your users are.\n"
                    },
                    "uuidLdapAttribute": {
                        "type": "string",
                        "description": "Name of the LDAP attribute to use as a unique object identifier for objects in LDAP.\n"
                    },
                    "validatePasswordPolicy": {
                        "type": "boolean",
                        "description": "When true, Keycloak will validate passwords using the realm policy before updating it.\n"
                    },
                    "vendor": {
                        "type": "string",
                        "description": "LDAP vendor. I am almost certain this field does nothing, but the UI indicates that it is required.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:oidc/googleIdentityProvider:GoogleIdentityProvider": {
            "properties": {
                "acceptsPromptNoneForwardFromClient": {
                    "type": "boolean",
                    "description": "This is just used together with Identity Provider Authenticator or when kc_idp_hint points to this identity provider. In\ncase that client sends a request with prompt=none and user is not yet authenticated, the error will not be directly\nreturned to client, but the request with prompt=none will be forwarded to this identity provider.\n"
                },
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.\n"
                },
                "alias": {
                    "type": "string",
                    "description": "The alias uniquely identifies an identity provider and it is also used to build the redirect uri. In case of google this\nis computed and always google\n"
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Enable/disable authenticate users by default.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "Client ID.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "Client Secret.\n"
                },
                "defaultScopes": {
                    "type": "string",
                    "description": "The scopes to be sent when asking for authorization. See the documentation for possible values, separator and default\nvalue'. Default: 'openid profile email'\n"
                },
                "disableUserInfo": {
                    "type": "boolean",
                    "description": "Disable usage of User Info service to obtain additional user information? Default is to use this OIDC service.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "Not used by this provider, Will be implicitly Google\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable/disable this identity provider.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means\nthat there is not yet existing Keycloak account linked with the authenticated identity provider account.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "Hide On Login Page.\n"
                },
                "hostedDomain": {
                    "type": "string",
                    "description": "Set 'hd' query parameter when logging in with Google. Google will list accounts only for this domain. Keycloak validates\nthat the returned identity token has a claim for this domain. When '*' is entered, any hosted account can be used.\n"
                },
                "internalId": {
                    "type": "string",
                    "description": "Internal Identity Provider Id\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't\nwant to allow login from the provider, but want to integrate with a provider\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want\nadditional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if\nyou don't want any additional authenticators to be triggered after login with this identity provider. Also note, that\nauthenticator implementations must assume that user is already set in ClientSession as identity provider already set it.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "provider id, is always google, unless you have a extended custom implementation\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "requestRefreshToken": {
                    "type": "boolean",
                    "description": "Set 'access_type' query parameter to 'offline' when redirecting to google authorization endpoint, to get a refresh token\nback. Useful if planning to use Token Exchange to retrieve Google token to access Google APIs when the user is not at\nthe browser.\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "Enable/disable if tokens must be stored after authenticating users.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "If enabled then email provided by this provider is not verified even if verification is enabled for the realm.\n"
                },
                "useUserIpParam": {
                    "type": "boolean",
                    "description": "Set 'userIp' query parameter when invoking on Google's User Info service. This will use the user's ip address. Useful if\nGoogle is throttling access to the User Info service.\n"
                }
            },
            "required": [
                "alias",
                "clientId",
                "clientSecret",
                "displayName",
                "internalId",
                "realm"
            ],
            "inputProperties": {
                "acceptsPromptNoneForwardFromClient": {
                    "type": "boolean",
                    "description": "This is just used together with Identity Provider Authenticator or when kc_idp_hint points to this identity provider. In\ncase that client sends a request with prompt=none and user is not yet authenticated, the error will not be directly\nreturned to client, but the request with prompt=none will be forwarded to this identity provider.\n"
                },
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.\n"
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Enable/disable authenticate users by default.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "Client ID.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "Client Secret.\n"
                },
                "defaultScopes": {
                    "type": "string",
                    "description": "The scopes to be sent when asking for authorization. See the documentation for possible values, separator and default\nvalue'. Default: 'openid profile email'\n"
                },
                "disableUserInfo": {
                    "type": "boolean",
                    "description": "Disable usage of User Info service to obtain additional user information? Default is to use this OIDC service.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable/disable this identity provider.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means\nthat there is not yet existing Keycloak account linked with the authenticated identity provider account.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "Hide On Login Page.\n"
                },
                "hostedDomain": {
                    "type": "string",
                    "description": "Set 'hd' query parameter when logging in with Google. Google will list accounts only for this domain. Keycloak validates\nthat the returned identity token has a claim for this domain. When '*' is entered, any hosted account can be used.\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't\nwant to allow login from the provider, but want to integrate with a provider\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want\nadditional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if\nyou don't want any additional authenticators to be triggered after login with this identity provider. Also note, that\nauthenticator implementations must assume that user is already set in ClientSession as identity provider already set it.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "provider id, is always google, unless you have a extended custom implementation\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "requestRefreshToken": {
                    "type": "boolean",
                    "description": "Set 'access_type' query parameter to 'offline' when redirecting to google authorization endpoint, to get a refresh token\nback. Useful if planning to use Token Exchange to retrieve Google token to access Google APIs when the user is not at\nthe browser.\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "Enable/disable if tokens must be stored after authenticating users.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "If enabled then email provided by this provider is not verified even if verification is enabled for the realm.\n"
                },
                "useUserIpParam": {
                    "type": "boolean",
                    "description": "Set 'userIp' query parameter when invoking on Google's User Info service. This will use the user's ip address. Useful if\nGoogle is throttling access to the User Info service.\n"
                }
            },
            "requiredInputs": [
                "clientId",
                "clientSecret",
                "realm"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GoogleIdentityProvider resources.\n",
                "properties": {
                    "acceptsPromptNoneForwardFromClient": {
                        "type": "boolean",
                        "description": "This is just used together with Identity Provider Authenticator or when kc_idp_hint points to this identity provider. In\ncase that client sends a request with prompt=none and user is not yet authenticated, the error will not be directly\nreturned to client, but the request with prompt=none will be forwarded to this identity provider.\n"
                    },
                    "addReadTokenRoleOnCreate": {
                        "type": "boolean",
                        "description": "Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.\n"
                    },
                    "alias": {
                        "type": "string",
                        "description": "The alias uniquely identifies an identity provider and it is also used to build the redirect uri. In case of google this\nis computed and always google\n"
                    },
                    "authenticateByDefault": {
                        "type": "boolean",
                        "description": "Enable/disable authenticate users by default.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "Client ID.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "Client Secret.\n"
                    },
                    "defaultScopes": {
                        "type": "string",
                        "description": "The scopes to be sent when asking for authorization. See the documentation for possible values, separator and default\nvalue'. Default: 'openid profile email'\n"
                    },
                    "disableUserInfo": {
                        "type": "boolean",
                        "description": "Disable usage of User Info service to obtain additional user information? Default is to use this OIDC service.\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "Not used by this provider, Will be implicitly Google\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable/disable this identity provider.\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "firstBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means\nthat there is not yet existing Keycloak account linked with the authenticated identity provider account.\n"
                    },
                    "hideOnLoginPage": {
                        "type": "boolean",
                        "description": "Hide On Login Page.\n"
                    },
                    "hostedDomain": {
                        "type": "string",
                        "description": "Set 'hd' query parameter when logging in with Google. Google will list accounts only for this domain. Keycloak validates\nthat the returned identity token has a claim for this domain. When '*' is entered, any hosted account can be used.\n"
                    },
                    "internalId": {
                        "type": "string",
                        "description": "Internal Identity Provider Id\n"
                    },
                    "linkOnly": {
                        "type": "boolean",
                        "description": "If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't\nwant to allow login from the provider, but want to integrate with a provider\n"
                    },
                    "postBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want\nadditional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if\nyou don't want any additional authenticators to be triggered after login with this identity provider. Also note, that\nauthenticator implementations must assume that user is already set in ClientSession as identity provider already set it.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "provider id, is always google, unless you have a extended custom implementation\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "Realm Name\n"
                    },
                    "requestRefreshToken": {
                        "type": "boolean",
                        "description": "Set 'access_type' query parameter to 'offline' when redirecting to google authorization endpoint, to get a refresh token\nback. Useful if planning to use Token Exchange to retrieve Google token to access Google APIs when the user is not at\nthe browser.\n"
                    },
                    "storeToken": {
                        "type": "boolean",
                        "description": "Enable/disable if tokens must be stored after authenticating users.\n"
                    },
                    "trustEmail": {
                        "type": "boolean",
                        "description": "If enabled then email provided by this provider is not verified even if verification is enabled for the realm.\n"
                    },
                    "useUserIpParam": {
                        "type": "boolean",
                        "description": "Set 'userIp' query parameter when invoking on Google's User Info service. This will use the user's ip address. Useful if\nGoogle is throttling access to the User Info service.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:oidc/identityProvider:IdentityProvider": {
            "description": "## # keycloak.oidc.IdentityProvider\n\nAllows to create and manage OIDC Identity Providers within Keycloak.\n\nOIDC (OpenID Connect) identity providers allows to authenticate through a third-party system, using OIDC standard.\n\n### Example Usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst my_realm = new keycloak.Realm(\"my-realm\", {\n    displayName: \"my-realm\",\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst realmIdentityProvider = new keycloak.oidc.IdentityProvider(\"realm_identity_provider\", {\n    alias: \"my-idp\",\n    authorizationUrl: \"https://authorizationurl.com\",\n    clientId: \"clientID\",\n    clientSecret: \"clientSecret\", // or \"$${vault.ID}\"\n    extraConfig: {\n        clientAuthMethod: \"client_secret_post\",\n    },\n    realm: \"my-realm\",\n    tokenUrl: \"https://tokenurl.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nmy_realm = keycloak.Realm(\"my-realm\",\n    display_name=\"my-realm\",\n    enabled=True,\n    realm=\"my-realm\")\nrealm_identity_provider = keycloak.oidc.IdentityProvider(\"realmIdentityProvider\",\n    alias=\"my-idp\",\n    authorization_url=\"https://authorizationurl.com\",\n    client_id=\"clientID\",\n    client_secret=\"clientSecret\",\n    extra_config={\n        \"clientAuthMethod\": \"client_secret_post\",\n    },\n    realm=\"my-realm\",\n    token_url=\"https://tokenurl.com\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var my_realm = new Keycloak.Realm(\"my-realm\", new Keycloak.RealmArgs\n        {\n            DisplayName = \"my-realm\",\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var realmIdentityProvider = new Keycloak.Oidc.IdentityProvider(\"realmIdentityProvider\", new Keycloak.Oidc.IdentityProviderArgs\n        {\n            Alias = \"my-idp\",\n            AuthorizationUrl = \"https://authorizationurl.com\",\n            ClientId = \"clientID\",\n            ClientSecret = \"clientSecret\",\n            ExtraConfig = \n            {\n                { \"clientAuthMethod\", \"client_secret_post\" },\n            },\n            Realm = \"my-realm\",\n            TokenUrl = \"https://tokenurl.com\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/oidc\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := keycloak.NewRealm(ctx, \"my_realm\", \u0026keycloak.RealmArgs{\n\t\t\tDisplayName: pulumi.String(\"my-realm\"),\n\t\t\tEnabled:     pulumi.Bool(true),\n\t\t\tRealm:       pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = oidc.NewIdentityProvider(ctx, \"realmIdentityProvider\", \u0026oidc.IdentityProviderArgs{\n\t\t\tAlias:            pulumi.String(\"my-idp\"),\n\t\t\tAuthorizationUrl: pulumi.String(\"https://authorizationurl.com\"),\n\t\t\tClientId:         pulumi.String(\"clientID\"),\n\t\t\tClientSecret:     pulumi.String(\"clientSecret\"),\n\t\t\tExtraConfig: pulumi.StringMap{\n\t\t\t\t\"clientAuthMethod\": pulumi.String(\"client_secret_post\"),\n\t\t\t},\n\t\t\tRealm:    pulumi.String(\"my-realm\"),\n\t\t\tTokenUrl: pulumi.String(\"https://tokenurl.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm` - (Required) The name of the realm. This is unique across Keycloak.\n- `alias` - (Required) The alias uniquely identifies an identity provider and it is also used to build the redirect uri.\n- `authorization_url` - (Required) The Authorization Url.\n- `client_id` - (Required) The client or client identifier registered within the identity provider.\n- `client_secret` - (Required) The client or client secret registered within the identity provider. This field is able to obtain its value from vault, use $${vault.ID} format.\n- `token_url` - (Required) The Token URL.\n- `extra_config` - (Optional) this block is needed to set extra configuration (Not yet supported variables or custom extensions)\n    - `clientAuthMethod` (Optional) The client authentication method. Since Keycloak 8, this is a required attribute if OIDC provider is created over the Keycloak Userinterface.\n    It accepts the values `client_secret_post` (Client secret sent as post), `client_secret_basic` (Client secret sent as basic auth), `client_secret_jwt` (Client secret as jwt) and `private_key_jwt ` (JTW signed with private key)\n- `provider_id` - (Optional) The Provider id, defaults to `oidc`, unless you have a custom implementation.\n- `backchannel_supported` - (Optional) Does the external IDP support backchannel logout ? Defaults to `true`.\n- `validate_signature` - (Optional) Enable/disable signature validation of external IDP signatures. Defaults to `false`.\n- `user_info_url` - (Optional) User Info URL.\n- `jwks_url` - (Optional) JSON Web Key Set URL.\n- `hide_on_login_page` - (Optional) Hide On Login Page. Defaults to `false`.\n- `logout_url` - (Optional) The Logout URL is the end session endpoint to use to logout user from external identity provider.\n- `login_hint` - (Optional) Pass login hint to identity provider.\n- `ui_locales` - (Optional) Pass current locale to identity provider. Defaults to `false`.\n- `accepts_prompt_none_forward_from_client` (Optional) Specifies whether the IDP accepts forwarded authentication requests that contain the prompt=none query parameter or not\n- `default_scopes` - (Optional) The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to 'openid'.\n",
            "properties": {
                "acceptsPromptNoneForwardFromClient": {
                    "type": "boolean",
                    "description": "This is just used together with Identity Provider Authenticator or when kc_idp_hint points to this identity provider. In\ncase that client sends a request with prompt=none and user is not yet authenticated, the error will not be directly\nreturned to client, but the request with prompt=none will be forwarded to this identity provider.\n"
                },
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.\n"
                },
                "alias": {
                    "type": "string",
                    "description": "The alias uniquely identifies an identity provider and it is also used to build the redirect uri.\n"
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Enable/disable authenticate users by default.\n"
                },
                "authorizationUrl": {
                    "type": "string",
                    "description": "OIDC authorization URL.\n"
                },
                "backchannelSupported": {
                    "type": "boolean",
                    "description": "Does the external IDP support backchannel logout?\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "Client ID.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "Client Secret.\n"
                },
                "defaultScopes": {
                    "type": "string",
                    "description": "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to 'openid'.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "Friendly name for Identity Providers.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable/disable this identity provider.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means\nthat there is not yet existing Keycloak account linked with the authenticated identity provider account.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "Hide On Login Page.\n"
                },
                "internalId": {
                    "type": "string",
                    "description": "Internal Identity Provider Id\n"
                },
                "jwksUrl": {
                    "type": "string",
                    "description": "JSON Web Key Set URL\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't\nwant to allow login from the provider, but want to integrate with a provider\n"
                },
                "loginHint": {
                    "type": "string",
                    "description": "Login Hint.\n"
                },
                "logoutUrl": {
                    "type": "string",
                    "description": "Logout URL\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want\nadditional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if\nyou don't want any additional authenticators to be triggered after login with this identity provider. Also note, that\nauthenticator implementations must assume that user is already set in ClientSession as identity provider already set it.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "provider id, is always oidc, unless you have a custom implementation\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "Enable/disable if tokens must be stored after authenticating users.\n"
                },
                "tokenUrl": {
                    "type": "string",
                    "description": "Token URL.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "If enabled then email provided by this provider is not verified even if verification is enabled for the realm.\n"
                },
                "uiLocales": {
                    "type": "boolean",
                    "description": "Pass current locale to identity provider\n"
                },
                "userInfoUrl": {
                    "type": "string",
                    "description": "User Info URL\n"
                },
                "validateSignature": {
                    "type": "boolean",
                    "description": "Enable/disable signature validation of external IDP signatures.\n"
                }
            },
            "required": [
                "alias",
                "authorizationUrl",
                "clientId",
                "clientSecret",
                "internalId",
                "realm",
                "tokenUrl"
            ],
            "inputProperties": {
                "acceptsPromptNoneForwardFromClient": {
                    "type": "boolean",
                    "description": "This is just used together with Identity Provider Authenticator or when kc_idp_hint points to this identity provider. In\ncase that client sends a request with prompt=none and user is not yet authenticated, the error will not be directly\nreturned to client, but the request with prompt=none will be forwarded to this identity provider.\n"
                },
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.\n"
                },
                "alias": {
                    "type": "string",
                    "description": "The alias uniquely identifies an identity provider and it is also used to build the redirect uri.\n"
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Enable/disable authenticate users by default.\n"
                },
                "authorizationUrl": {
                    "type": "string",
                    "description": "OIDC authorization URL.\n"
                },
                "backchannelSupported": {
                    "type": "boolean",
                    "description": "Does the external IDP support backchannel logout?\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "Client ID.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "Client Secret.\n"
                },
                "defaultScopes": {
                    "type": "string",
                    "description": "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to 'openid'.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "Friendly name for Identity Providers.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable/disable this identity provider.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means\nthat there is not yet existing Keycloak account linked with the authenticated identity provider account.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "Hide On Login Page.\n"
                },
                "jwksUrl": {
                    "type": "string",
                    "description": "JSON Web Key Set URL\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't\nwant to allow login from the provider, but want to integrate with a provider\n"
                },
                "loginHint": {
                    "type": "string",
                    "description": "Login Hint.\n"
                },
                "logoutUrl": {
                    "type": "string",
                    "description": "Logout URL\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want\nadditional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if\nyou don't want any additional authenticators to be triggered after login with this identity provider. Also note, that\nauthenticator implementations must assume that user is already set in ClientSession as identity provider already set it.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "provider id, is always oidc, unless you have a custom implementation\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "Enable/disable if tokens must be stored after authenticating users.\n"
                },
                "tokenUrl": {
                    "type": "string",
                    "description": "Token URL.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "If enabled then email provided by this provider is not verified even if verification is enabled for the realm.\n"
                },
                "uiLocales": {
                    "type": "boolean",
                    "description": "Pass current locale to identity provider\n"
                },
                "userInfoUrl": {
                    "type": "string",
                    "description": "User Info URL\n"
                },
                "validateSignature": {
                    "type": "boolean",
                    "description": "Enable/disable signature validation of external IDP signatures.\n"
                }
            },
            "requiredInputs": [
                "alias",
                "authorizationUrl",
                "clientId",
                "clientSecret",
                "realm",
                "tokenUrl"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IdentityProvider resources.\n",
                "properties": {
                    "acceptsPromptNoneForwardFromClient": {
                        "type": "boolean",
                        "description": "This is just used together with Identity Provider Authenticator or when kc_idp_hint points to this identity provider. In\ncase that client sends a request with prompt=none and user is not yet authenticated, the error will not be directly\nreturned to client, but the request with prompt=none will be forwarded to this identity provider.\n"
                    },
                    "addReadTokenRoleOnCreate": {
                        "type": "boolean",
                        "description": "Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.\n"
                    },
                    "alias": {
                        "type": "string",
                        "description": "The alias uniquely identifies an identity provider and it is also used to build the redirect uri.\n"
                    },
                    "authenticateByDefault": {
                        "type": "boolean",
                        "description": "Enable/disable authenticate users by default.\n"
                    },
                    "authorizationUrl": {
                        "type": "string",
                        "description": "OIDC authorization URL.\n"
                    },
                    "backchannelSupported": {
                        "type": "boolean",
                        "description": "Does the external IDP support backchannel logout?\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "Client ID.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "Client Secret.\n"
                    },
                    "defaultScopes": {
                        "type": "string",
                        "description": "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to 'openid'.\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "Friendly name for Identity Providers.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable/disable this identity provider.\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "firstBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means\nthat there is not yet existing Keycloak account linked with the authenticated identity provider account.\n"
                    },
                    "hideOnLoginPage": {
                        "type": "boolean",
                        "description": "Hide On Login Page.\n"
                    },
                    "internalId": {
                        "type": "string",
                        "description": "Internal Identity Provider Id\n"
                    },
                    "jwksUrl": {
                        "type": "string",
                        "description": "JSON Web Key Set URL\n"
                    },
                    "linkOnly": {
                        "type": "boolean",
                        "description": "If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't\nwant to allow login from the provider, but want to integrate with a provider\n"
                    },
                    "loginHint": {
                        "type": "string",
                        "description": "Login Hint.\n"
                    },
                    "logoutUrl": {
                        "type": "string",
                        "description": "Logout URL\n"
                    },
                    "postBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want\nadditional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if\nyou don't want any additional authenticators to be triggered after login with this identity provider. Also note, that\nauthenticator implementations must assume that user is already set in ClientSession as identity provider already set it.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "provider id, is always oidc, unless you have a custom implementation\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "Realm Name\n"
                    },
                    "storeToken": {
                        "type": "boolean",
                        "description": "Enable/disable if tokens must be stored after authenticating users.\n"
                    },
                    "tokenUrl": {
                        "type": "string",
                        "description": "Token URL.\n"
                    },
                    "trustEmail": {
                        "type": "boolean",
                        "description": "If enabled then email provided by this provider is not verified even if verification is enabled for the realm.\n"
                    },
                    "uiLocales": {
                        "type": "boolean",
                        "description": "Pass current locale to identity provider\n"
                    },
                    "userInfoUrl": {
                        "type": "string",
                        "description": "User Info URL\n"
                    },
                    "validateSignature": {
                        "type": "boolean",
                        "description": "Enable/disable signature validation of external IDP signatures.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/audienceProtocolMapper:AudienceProtocolMapper": {
            "description": "## # keycloak.openid.AudienceProtocolMapper\n\nAllows for creating and managing audience protocol mappers within\nKeycloak. This mapper was added in Keycloak v4.6.0.Final.\n\nAudience protocol mappers allow you add audiences to the `aud` claim\nwithin issued tokens. The audience can be a custom string, or it can be\nmapped to the ID of a pre-existing client.\n\n### Example Usage (Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    accessType: \"CONFIDENTIAL\",\n    clientId: \"test-client\",\n    enabled: true,\n    realmId: realm.id,\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst audienceMapper = new keycloak.openid.AudienceProtocolMapper(\"audience_mapper\", {\n    clientId: openidClient.id,\n    includedCustomAudience: \"foo\",\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    access_type=\"CONFIDENTIAL\",\n    client_id=\"test-client\",\n    enabled=True,\n    realm_id=realm.id,\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\naudience_mapper = keycloak.openid.AudienceProtocolMapper(\"audienceMapper\",\n    client_id=openid_client.id,\n    included_custom_audience=\"foo\",\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            AccessType = \"CONFIDENTIAL\",\n            ClientId = \"test-client\",\n            Enabled = true,\n            RealmId = realm.Id,\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var audienceMapper = new Keycloak.OpenId.AudienceProtocolMapper(\"audienceMapper\", new Keycloak.OpenId.AudienceProtocolMapperArgs\n        {\n            ClientId = openidClient.Id,\n            IncludedCustomAudience = \"foo\",\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tRealmId:    realm.ID(),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewAudienceProtocolMapper(ctx, \"audienceMapper\", \u0026openid.AudienceProtocolMapperArgs{\n\t\t\tClientId:               openidClient.ID(),\n\t\t\tIncludedCustomAudience: pulumi.String(\"foo\"),\n\t\t\tRealmId:                realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Example Usage (Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n});\nconst audienceMapper = new keycloak.openid.AudienceProtocolMapper(\"audience_mapper\", {\n    clientScopeId: clientScope.id,\n    includedCustomAudience: \"foo\",\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\naudience_mapper = keycloak.openid.AudienceProtocolMapper(\"audienceMapper\",\n    client_scope_id=client_scope.id,\n    included_custom_audience=\"foo\",\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var audienceMapper = new Keycloak.OpenId.AudienceProtocolMapper(\"audienceMapper\", new Keycloak.OpenId.AudienceProtocolMapperArgs\n        {\n            ClientScopeId = clientScope.Id,\n            IncludedCustomAudience = \"foo\",\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewAudienceProtocolMapper(ctx, \"audienceMapper\", \u0026openid.AudienceProtocolMapperArgs{\n\t\t\tClientScopeId:          clientScope.ID(),\n\t\t\tIncludedCustomAudience: pulumi.String(\"foo\"),\n\t\t\tRealmId:                realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `included_client_audience` - (Required if `included_custom_audience` is not specified) A client ID to include within the token's `aud` claim.\n- `included_custom_audience` - (Required if `included_client_audience` is not specified) A custom audience to include within the token's `aud` claim.\n- `add_to_id_token` - (Optional) Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.\n- `add_to_access_token` - (Optional) Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.\n",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if this claim should be added to the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if this claim should be added to the id token.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "includedClientAudience": {
                    "type": "string",
                    "description": "A client ID to include within the token's `aud` claim. Cannot be used with included_custom_audience\n"
                },
                "includedCustomAudience": {
                    "type": "string",
                    "description": "A custom audience to include within the token's `aud` claim. Cannot be used with included_custom_audience\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if this claim should be added to the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if this claim should be added to the id token.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "includedClientAudience": {
                    "type": "string",
                    "description": "A client ID to include within the token's `aud` claim. Cannot be used with included_custom_audience\n"
                },
                "includedCustomAudience": {
                    "type": "string",
                    "description": "A custom audience to include within the token's `aud` claim. Cannot be used with included_custom_audience\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AudienceProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if this claim should be added to the access token.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if this claim should be added to the id token.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                    },
                    "includedClientAudience": {
                        "type": "string",
                        "description": "A client ID to include within the token's `aud` claim. Cannot be used with included_custom_audience\n"
                    },
                    "includedCustomAudience": {
                        "type": "string",
                        "description": "A custom audience to include within the token's `aud` claim. Cannot be used with included_custom_audience\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-friendly name that will appear in the Keycloak console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id where the associated client or client scope exists.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/client:Client": {
            "description": "## # keycloak.openid.Client\n\nAllows for creating and managing Keycloak clients that use the OpenID Connect protocol.\n\nClients are entities that can use Keycloak for user authentication. Typically,\nclients are applications that redirect users to Keycloak for authentication\nin order to take advantage of Keycloak's user sessions for SSO.\n\n### Example Usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    accessType: \"CONFIDENTIAL\",\n    clientId: \"test-client\",\n    enabled: true,\n    loginTheme: \"keycloak\",\n    realmId: realm.id,\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    access_type=\"CONFIDENTIAL\",\n    client_id=\"test-client\",\n    enabled=True,\n    login_theme=\"keycloak\",\n    realm_id=realm.id,\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            AccessType = \"CONFIDENTIAL\",\n            ClientId = \"test-client\",\n            Enabled = true,\n            LoginTheme = \"keycloak\",\n            RealmId = realm.Id,\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tLoginTheme: pulumi.String(\"keycloak\"),\n\t\t\tRealmId:    realm.ID(),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this client is attached to.\n- `client_id` - (Required) The unique ID of this client, referenced in the URI during authentication and in issued tokens.\n- `name` - (Optional) The display name of this client in the GUI.\n- `enabled` - (Optional) When false, this client will not be able to initiate a login or obtain access tokens. Defaults to `true`.\n- `description` - (Optional) The description of this client in the GUI.\n- `access_type` - (Required) Specifies the type of client, which can be one of the following:\n    - `CONFIDENTIAL` - Used for server-side clients that require both client ID and secret when authenticating.\n      This client should be used for applications using the Authorization Code or Client Credentials grant flows.\n    - `PUBLIC` - Used for browser-only applications that do not require a client secret, and instead rely only on authorized redirect\n      URIs for security. This client should be used for applications using the Implicit grant flow.\n    - `BEARER-ONLY` - Used for services that never initiate a login. This client will only allow bearer token requests.\n- `client_secret` - (Optional) The secret for clients with an `access_type` of `CONFIDENTIAL` or `BEARER-ONLY`. This value is sensitive and\nshould be treated with the same care as a password. If omitted, Keycloak will generate a GUID for this attribute.\n- `standard_flow_enabled` - (Optional) When `true`, the OAuth2 Authorization Code Grant will be enabled for this client. Defaults to `false`.\n- `implicit_flow_enabled` - (Optional) When `true`, the OAuth2 Implicit Grant will be enabled for this client. Defaults to `false`.\n- `direct_access_grants_enabled` - (Optional) When `true`, the OAuth2 Resource Owner Password Grant will be enabled for this client. Defaults to `false`.\n- `service_accounts_enabled` - (Optional) When `true`, the OAuth2 Client Credentials grant will be enabled for this client. Defaults to `false`.\n- `valid_redirect_uris` - (Optional) A list of valid URIs a browser is permitted to redirect to after a successful login or logout. Simple\nwildcards in the form of an asterisk can be used here. This attribute must be set if either `standard_flow_enabled` or `implicit_flow_enabled`\nis set to `true`.\n- `web_origins` - (Optional) A list of allowed CORS origins. `+` can be used to permit all valid redirect URIs, and `*` can be used to permit all origins.\n- `root_url` - (Optional) When specified, this URL is prepended to any relative URLs found within `valid_redirect_uris`, `web_origins`, and `admin_url`.\n    - NOTE: Due to limitations in the Keycloak API, when the `root_url` attribute is used, the `valid_redirect_uris`, `web_origins`, and `admin_url` attributes will be required.\n- `admin_url` - (Optional) URL to the admin interface of the client.\n- `base_url` - (Optional) Default URL to use when the auth server needs to redirect or link back to the client.\n- `pkce_code_challenge_method` - (Optional) The challenge method to use for Proof Key for Code Exchange. Can be either `plain` or `S256` or set to empty value ``.\n- `full_scope_allowed` - (Optional) - Allow to include all roles mappings in the access token.\n- `access_token_lifespan` - (Optional) - Allow to set the lifespan of the access token\n- `consent_required` - (Optional) - Consent Required: If enabled, users have to consent to client access.\n- `authentication_flow_binding_overrides` - (Optional) - Override realm authentication flow bindings\n    - `browers_id` - (Optional) - Browser flow id, (flow needs to exist)\n    - `direct_grant_id` - (Optional) - Direct grant flow id (flow needs to exist)\n- `login_theme` - (Optional) - Override realm login theme\n\n### Attributes Reference\n\nIn addition to the arguments listed above, the following computed attributes are exported:\n\n- `service_account_user_id` - When service accounts are enabled for this client, this attribute is the unique ID for the Keycloak user that represents this service account.\n\n",
            "properties": {
                "accessTokenLifespan": {
                    "type": "string"
                },
                "accessType": {
                    "type": "string"
                },
                "adminUrl": {
                    "type": "string"
                },
                "authenticationFlowBindingOverrides": {
                    "$ref": "#/types/keycloak:openid/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides"
                },
                "authorization": {
                    "$ref": "#/types/keycloak:openid/ClientAuthorization:ClientAuthorization"
                },
                "baseUrl": {
                    "type": "string"
                },
                "clientId": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string"
                },
                "consentRequired": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string"
                },
                "directAccessGrantsEnabled": {
                    "type": "boolean"
                },
                "enabled": {
                    "type": "boolean"
                },
                "excludeSessionStateFromAuthResponse": {
                    "type": "boolean"
                },
                "fullScopeAllowed": {
                    "type": "boolean"
                },
                "implicitFlowEnabled": {
                    "type": "boolean"
                },
                "loginTheme": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "pkceCodeChallengeMethod": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "rootUrl": {
                    "type": "string"
                },
                "serviceAccountUserId": {
                    "type": "string"
                },
                "serviceAccountsEnabled": {
                    "type": "boolean"
                },
                "standardFlowEnabled": {
                    "type": "boolean"
                },
                "validRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "webOrigins": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "accessType",
                "clientId",
                "clientSecret",
                "name",
                "realmId",
                "resourceServerId",
                "serviceAccountUserId"
            ],
            "inputProperties": {
                "accessTokenLifespan": {
                    "type": "string"
                },
                "accessType": {
                    "type": "string"
                },
                "adminUrl": {
                    "type": "string"
                },
                "authenticationFlowBindingOverrides": {
                    "$ref": "#/types/keycloak:openid/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides"
                },
                "authorization": {
                    "$ref": "#/types/keycloak:openid/ClientAuthorization:ClientAuthorization"
                },
                "baseUrl": {
                    "type": "string"
                },
                "clientId": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string"
                },
                "consentRequired": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string"
                },
                "directAccessGrantsEnabled": {
                    "type": "boolean"
                },
                "enabled": {
                    "type": "boolean"
                },
                "excludeSessionStateFromAuthResponse": {
                    "type": "boolean"
                },
                "fullScopeAllowed": {
                    "type": "boolean"
                },
                "implicitFlowEnabled": {
                    "type": "boolean"
                },
                "loginTheme": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "pkceCodeChallengeMethod": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "rootUrl": {
                    "type": "string"
                },
                "serviceAccountsEnabled": {
                    "type": "boolean"
                },
                "standardFlowEnabled": {
                    "type": "boolean"
                },
                "validRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "webOrigins": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "requiredInputs": [
                "accessType",
                "clientId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Client resources.\n",
                "properties": {
                    "accessTokenLifespan": {
                        "type": "string"
                    },
                    "accessType": {
                        "type": "string"
                    },
                    "adminUrl": {
                        "type": "string"
                    },
                    "authenticationFlowBindingOverrides": {
                        "$ref": "#/types/keycloak:openid/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides"
                    },
                    "authorization": {
                        "$ref": "#/types/keycloak:openid/ClientAuthorization:ClientAuthorization"
                    },
                    "baseUrl": {
                        "type": "string"
                    },
                    "clientId": {
                        "type": "string"
                    },
                    "clientSecret": {
                        "type": "string"
                    },
                    "consentRequired": {
                        "type": "boolean"
                    },
                    "description": {
                        "type": "string"
                    },
                    "directAccessGrantsEnabled": {
                        "type": "boolean"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "excludeSessionStateFromAuthResponse": {
                        "type": "boolean"
                    },
                    "fullScopeAllowed": {
                        "type": "boolean"
                    },
                    "implicitFlowEnabled": {
                        "type": "boolean"
                    },
                    "loginTheme": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "pkceCodeChallengeMethod": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "rootUrl": {
                        "type": "string"
                    },
                    "serviceAccountUserId": {
                        "type": "string"
                    },
                    "serviceAccountsEnabled": {
                        "type": "boolean"
                    },
                    "standardFlowEnabled": {
                        "type": "boolean"
                    },
                    "validRedirectUris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "webOrigins": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientAggregatePolicy:ClientAggregatePolicy": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "required": [
                "decisionStrategy",
                "name",
                "policies",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "decisionStrategy",
                "policies",
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientAggregatePolicy resources.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientAuthorizationPermission:ClientAuthorizationPermission": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "resources": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "resources": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "type": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientAuthorizationPermission resources.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "resources": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientAuthorizationResource:ClientAuthorizationResource": {
            "properties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "displayName": {
                    "type": "string"
                },
                "iconUri": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "ownerManagedAccess": {
                    "type": "boolean"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "type": {
                    "type": "string"
                },
                "uris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "displayName": {
                    "type": "string"
                },
                "iconUri": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "ownerManagedAccess": {
                    "type": "boolean"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "type": {
                    "type": "string"
                },
                "uris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "requiredInputs": [
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientAuthorizationResource resources.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "displayName": {
                        "type": "string"
                    },
                    "iconUri": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "ownerManagedAccess": {
                        "type": "boolean"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "type": {
                        "type": "string"
                    },
                    "uris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientAuthorizationScope:ClientAuthorizationScope": {
            "properties": {
                "displayName": {
                    "type": "string"
                },
                "iconUri": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "displayName": {
                    "type": "string"
                },
                "iconUri": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientAuthorizationScope resources.\n",
                "properties": {
                    "displayName": {
                        "type": "string"
                    },
                    "iconUri": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientDefaultScopes:ClientDefaultScopes": {
            "properties": {
                "clientId": {
                    "type": "string"
                },
                "defaultScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "clientId",
                "defaultScopes",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string"
                },
                "defaultScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "clientId",
                "defaultScopes",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientDefaultScopes resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string"
                    },
                    "defaultScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientGroupPolicy:ClientGroupPolicy": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:openid/ClientGroupPolicyGroup:ClientGroupPolicyGroup"
                    }
                },
                "groupsClaim": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "required": [
                "decisionStrategy",
                "groups",
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:openid/ClientGroupPolicyGroup:ClientGroupPolicyGroup"
                    }
                },
                "groupsClaim": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "decisionStrategy",
                "groups",
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientGroupPolicy resources.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "groups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:openid/ClientGroupPolicyGroup:ClientGroupPolicyGroup"
                        }
                    },
                    "groupsClaim": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientJsPolicy:ClientJsPolicy": {
            "properties": {
                "code": {
                    "type": "string"
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "code",
                "decisionStrategy",
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "code": {
                    "type": "string"
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "code",
                "decisionStrategy",
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientJsPolicy resources.\n",
                "properties": {
                    "code": {
                        "type": "string"
                    },
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientOptionalScopes:ClientOptionalScopes": {
            "properties": {
                "clientId": {
                    "type": "string"
                },
                "optionalScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "clientId",
                "optionalScopes",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string"
                },
                "optionalScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "clientId",
                "optionalScopes",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientOptionalScopes resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string"
                    },
                    "optionalScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientPolicy:ClientPolicy": {
            "properties": {
                "clients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "required": [
                "clients",
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "clients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "clients",
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientPolicy resources.\n",
                "properties": {
                    "clients": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientRolePolicy:ClientRolePolicy": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:openid/ClientRolePolicyRole:ClientRolePolicyRole"
                    }
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId",
                "resourceServerId",
                "roles",
                "type"
            ],
            "inputProperties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:openid/ClientRolePolicyRole:ClientRolePolicyRole"
                    }
                },
                "type": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId",
                "resourceServerId",
                "roles",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientRolePolicy resources.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:openid/ClientRolePolicyRole:ClientRolePolicyRole"
                        }
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientScope:ClientScope": {
            "description": "## # keycloak.openid.ClientScope\n\nAllows for creating and managing Keycloak client scopes that can be attached to\nclients that use the OpenID Connect protocol.\n\nClient Scopes can be used to share common protocol and role mappings between multiple\nclients within a realm. They can also be used by clients to conditionally request\nclaims or roles for a user based on the OAuth 2.0 `scope` parameter.\n\n### Example Usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst openidClientScope = new keycloak.openid.ClientScope(\"openid_client_scope\", {\n    description: \"When requested, this scope will map a user's group memberships to a claim\",\n    guiOrder: 1,\n    includeInTokenScope: true,\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nopenid_client_scope = keycloak.openid.ClientScope(\"openidClientScope\",\n    description=\"When requested, this scope will map a user's group memberships to a claim\",\n    gui_order=1,\n    include_in_token_scope=True,\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var openidClientScope = new Keycloak.OpenId.ClientScope(\"openidClientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            Description = \"When requested, this scope will map a user's group memberships to a claim\",\n            GuiOrder = 1,\n            IncludeInTokenScope = true,\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientScope(ctx, \"openidClientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tDescription:         pulumi.String(\"When requested, this scope will map a user's group memberships to a claim\"),\n\t\t\tGuiOrder:            pulumi.Int(1),\n\t\t\tIncludeInTokenScope: pulumi.Bool(true),\n\t\t\tRealmId:             realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this client scope belongs to.\n- `name` - (Required) The display name of this client scope in the GUI.\n- `description` - (Optional) The description of this client scope in the GUI.\n- `consent_screen_text` - (Optional) When set, a consent screen will be displayed to users\nauthenticating to clients with this scope attached. The consent screen will display the string\nvalue of this attribute.\n- `include_in_token_scope` - (Optional) When `true`, the name of this client scope will be added to the access token property 'scope' as well as to the Token Introspection Endpoint response.\n- `gui_order` - (Optional) Specify order of the client scope in GUI (such as in Consent page) as integer.\n",
            "properties": {
                "consentScreenText": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "guiOrder": {
                    "type": "integer"
                },
                "includeInTokenScope": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "consentScreenText": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "guiOrder": {
                    "type": "integer"
                },
                "includeInTokenScope": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientScope resources.\n",
                "properties": {
                    "consentScreenText": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "guiOrder": {
                        "type": "integer"
                    },
                    "includeInTokenScope": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientServiceAccountRealmRole:ClientServiceAccountRealmRole": {
            "properties": {
                "realmId": {
                    "type": "string"
                },
                "role": {
                    "type": "string"
                },
                "serviceAccountUserId": {
                    "type": "string"
                }
            },
            "required": [
                "realmId",
                "role",
                "serviceAccountUserId"
            ],
            "inputProperties": {
                "realmId": {
                    "type": "string"
                },
                "role": {
                    "type": "string"
                },
                "serviceAccountUserId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId",
                "role",
                "serviceAccountUserId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientServiceAccountRealmRole resources.\n",
                "properties": {
                    "realmId": {
                        "type": "string"
                    },
                    "role": {
                        "type": "string"
                    },
                    "serviceAccountUserId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientServiceAccountRole:ClientServiceAccountRole": {
            "description": "## # keycloak.openid.ClientServiceAccountRole\n\nAllows for assigning roles to the service account of an openid client.\n\nYou need to set `service_accounts_enabled` to `true` for the openid client that should be assigned the role.\n\n### Example Usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\n// client1 provides a role to other clients\nconst client1 = new keycloak.openid.Client(\"client1\", {realmId: realm.id});\nconst client1Role = new keycloak.Role(\"client1Role\", {\n    realmId: realm.id,\n    clientId: client1.id,\n    description: \"A role that client1 provides\",\n});\n// client2 is assigned the role of client1\nconst client2 = new keycloak.openid.Client(\"client2\", {\n    realmId: realm.id,\n    serviceAccountsEnabled: true,\n});\nconst client2ServiceAccountRole = new keycloak.openid.ClientServiceAccountRole(\"client2ServiceAccountRole\", {\n    realmId: realm.id,\n    serviceAccountUserId: client2.serviceAccountUserId,\n    clientId: client1.id,\n    role: client1Role.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\n# client1 provides a role to other clients\nclient1 = keycloak.openid.Client(\"client1\", realm_id=realm.id)\nclient1_role = keycloak.Role(\"client1Role\",\n    realm_id=realm.id,\n    client_id=client1.id,\n    description=\"A role that client1 provides\")\n# client2 is assigned the role of client1\nclient2 = keycloak.openid.Client(\"client2\",\n    realm_id=realm.id,\n    service_accounts_enabled=True)\nclient2_service_account_role = keycloak.openid.ClientServiceAccountRole(\"client2ServiceAccountRole\",\n    realm_id=realm.id,\n    service_account_user_id=client2.service_account_user_id,\n    client_id=client1.id,\n    role=client1_role.name)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        // client1 provides a role to other clients\n        var client1 = new Keycloak.OpenId.Client(\"client1\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n        });\n        var client1Role = new Keycloak.Role(\"client1Role\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            ClientId = client1.Id,\n            Description = \"A role that client1 provides\",\n        });\n        // client2 is assigned the role of client1\n        var client2 = new Keycloak.OpenId.Client(\"client2\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ServiceAccountsEnabled = true,\n        });\n        var client2ServiceAccountRole = new Keycloak.OpenId.ClientServiceAccountRole(\"client2ServiceAccountRole\", new Keycloak.OpenId.ClientServiceAccountRoleArgs\n        {\n            RealmId = realm.Id,\n            ServiceAccountUserId = client2.ServiceAccountUserId,\n            ClientId = client1.Id,\n            Role = client1Role.Name,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient1, err := openid.NewClient(ctx, \"client1\", \u0026openid.ClientArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient1Role, err := keycloak.NewRole(ctx, \"client1Role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    client1.ID(),\n\t\t\tDescription: pulumi.String(\"A role that client1 provides\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient2, err := openid.NewClient(ctx, \"client2\", \u0026openid.ClientArgs{\n\t\t\tRealmId:                realm.ID(),\n\t\t\tServiceAccountsEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientServiceAccountRole(ctx, \"client2ServiceAccountRole\", \u0026openid.ClientServiceAccountRoleArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tServiceAccountUserId: client2.ServiceAccountUserId,\n\t\t\tClientId:             client1.ID(),\n\t\t\tRole:                 client1Role.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm the clients and roles belong to.\n- `service_account_user_id` - (Required) The id of the service account that is assigned the role (the service account of the client that \"consumes\" the role).\n- `client_id` - (Required) The id of the client that provides the role.\n- `role` - (Required) The name of the role that is assigned.\n",
            "properties": {
                "clientId": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "role": {
                    "type": "string"
                },
                "serviceAccountUserId": {
                    "type": "string"
                }
            },
            "required": [
                "clientId",
                "realmId",
                "role",
                "serviceAccountUserId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "role": {
                    "type": "string"
                },
                "serviceAccountUserId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "clientId",
                "realmId",
                "role",
                "serviceAccountUserId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientServiceAccountRole resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "role": {
                        "type": "string"
                    },
                    "serviceAccountUserId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientTimePolicy:ClientTimePolicy": {
            "properties": {
                "dayMonth": {
                    "type": "string"
                },
                "dayMonthEnd": {
                    "type": "string"
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "hour": {
                    "type": "string"
                },
                "hourEnd": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "minute": {
                    "type": "string"
                },
                "minuteEnd": {
                    "type": "string"
                },
                "month": {
                    "type": "string"
                },
                "monthEnd": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "notBefore": {
                    "type": "string"
                },
                "notOnOrAfter": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "year": {
                    "type": "string"
                },
                "yearEnd": {
                    "type": "string"
                }
            },
            "required": [
                "decisionStrategy",
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "dayMonth": {
                    "type": "string"
                },
                "dayMonthEnd": {
                    "type": "string"
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "hour": {
                    "type": "string"
                },
                "hourEnd": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "minute": {
                    "type": "string"
                },
                "minuteEnd": {
                    "type": "string"
                },
                "month": {
                    "type": "string"
                },
                "monthEnd": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "notBefore": {
                    "type": "string"
                },
                "notOnOrAfter": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "year": {
                    "type": "string"
                },
                "yearEnd": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "decisionStrategy",
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientTimePolicy resources.\n",
                "properties": {
                    "dayMonth": {
                        "type": "string"
                    },
                    "dayMonthEnd": {
                        "type": "string"
                    },
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "hour": {
                        "type": "string"
                    },
                    "hourEnd": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "minute": {
                        "type": "string"
                    },
                    "minuteEnd": {
                        "type": "string"
                    },
                    "month": {
                        "type": "string"
                    },
                    "monthEnd": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "notBefore": {
                        "type": "string"
                    },
                    "notOnOrAfter": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "year": {
                        "type": "string"
                    },
                    "yearEnd": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientUserPolicy:ClientUserPolicy": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "decisionStrategy",
                "name",
                "realmId",
                "resourceServerId",
                "users"
            ],
            "inputProperties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "requiredInputs": [
                "decisionStrategy",
                "realmId",
                "resourceServerId",
                "users"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientUserPolicy resources.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "users": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/fullNameProtocolMapper:FullNameProtocolMapper": {
            "description": "## # keycloak.openid.FullNameProtocolMapper\n\nAllows for creating and managing full name protocol mappers within\nKeycloak.\n\nFull name protocol mappers allow you to map a user's first and last name\nto the OpenID Connect `name` claim in a token. Protocol mappers can be defined\nfor a single client, or they can be defined for a client scope which can\nbe shared between multiple different clients.\n\n### Example Usage (Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    accessType: \"CONFIDENTIAL\",\n    clientId: \"test-client\",\n    enabled: true,\n    realmId: realm.id,\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst fullNameMapper = new keycloak.openid.FullNameProtocolMapper(\"full_name_mapper\", {\n    clientId: openidClient.id,\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    access_type=\"CONFIDENTIAL\",\n    client_id=\"test-client\",\n    enabled=True,\n    realm_id=realm.id,\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nfull_name_mapper = keycloak.openid.FullNameProtocolMapper(\"fullNameMapper\",\n    client_id=openid_client.id,\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            AccessType = \"CONFIDENTIAL\",\n            ClientId = \"test-client\",\n            Enabled = true,\n            RealmId = realm.Id,\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var fullNameMapper = new Keycloak.OpenId.FullNameProtocolMapper(\"fullNameMapper\", new Keycloak.OpenId.FullNameProtocolMapperArgs\n        {\n            ClientId = openidClient.Id,\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tRealmId:    realm.ID(),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewFullNameProtocolMapper(ctx, \"fullNameMapper\", \u0026openid.FullNameProtocolMapperArgs{\n\t\t\tClientId: openidClient.ID(),\n\t\t\tRealmId:  realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Example Usage (Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n});\nconst fullNameMapper = new keycloak.openid.FullNameProtocolMapper(\"full_name_mapper\", {\n    clientScopeId: clientScope.id,\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nfull_name_mapper = keycloak.openid.FullNameProtocolMapper(\"fullNameMapper\",\n    client_scope_id=client_scope.id,\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var fullNameMapper = new Keycloak.OpenId.FullNameProtocolMapper(\"fullNameMapper\", new Keycloak.OpenId.FullNameProtocolMapperArgs\n        {\n            ClientScopeId = clientScope.Id,\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewFullNameProtocolMapper(ctx, \"fullNameMapper\", \u0026openid.FullNameProtocolMapperArgs{\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tRealmId:       realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `add_to_id_token` - (Optional) Indicates if the user's full name should be added as a claim to the id token. Defaults to `true`.\n- `add_to_access_token` - (Optional) Indicates if the user's full name should be added as a claim to the access token. Defaults to `true`.\n- `add_to_userinfo` - (Optional) Indicates if the user's full name should be added as a claim to the UserInfo response body. Defaults to `true`.\n",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean"
                },
                "addToIdToken": {
                    "type": "boolean"
                },
                "addToUserinfo": {
                    "type": "boolean"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean"
                },
                "addToIdToken": {
                    "type": "boolean"
                },
                "addToUserinfo": {
                    "type": "boolean"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FullNameProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean"
                    },
                    "addToIdToken": {
                        "type": "boolean"
                    },
                    "addToUserinfo": {
                        "type": "boolean"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-friendly name that will appear in the Keycloak console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id where the associated client or client scope exists.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/groupMembershipProtocolMapper:GroupMembershipProtocolMapper": {
            "description": "## # keycloak.openid.GroupMembershipProtocolMapper\n\nAllows for creating and managing group membership protocol mappers within\nKeycloak.\n\nGroup membership protocol mappers allow you to map a user's group memberships\nto a claim in a token. Protocol mappers can be defined for a single client,\nor they can be defined for a client scope which can be shared between multiple\ndifferent clients.\n\n### Example Usage (Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    accessType: \"CONFIDENTIAL\",\n    clientId: \"test-client\",\n    enabled: true,\n    realmId: realm.id,\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst groupMembershipMapper = new keycloak.openid.GroupMembershipProtocolMapper(\"group_membership_mapper\", {\n    claimName: \"groups\",\n    clientId: openidClient.id,\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    access_type=\"CONFIDENTIAL\",\n    client_id=\"test-client\",\n    enabled=True,\n    realm_id=realm.id,\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\ngroup_membership_mapper = keycloak.openid.GroupMembershipProtocolMapper(\"groupMembershipMapper\",\n    claim_name=\"groups\",\n    client_id=openid_client.id,\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            AccessType = \"CONFIDENTIAL\",\n            ClientId = \"test-client\",\n            Enabled = true,\n            RealmId = realm.Id,\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var groupMembershipMapper = new Keycloak.OpenId.GroupMembershipProtocolMapper(\"groupMembershipMapper\", new Keycloak.OpenId.GroupMembershipProtocolMapperArgs\n        {\n            ClaimName = \"groups\",\n            ClientId = openidClient.Id,\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tRealmId:    realm.ID(),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewGroupMembershipProtocolMapper(ctx, \"groupMembershipMapper\", \u0026openid.GroupMembershipProtocolMapperArgs{\n\t\t\tClaimName: pulumi.String(\"groups\"),\n\t\t\tClientId:  openidClient.ID(),\n\t\t\tRealmId:   realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Example Usage (Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n});\nconst groupMembershipMapper = new keycloak.openid.GroupMembershipProtocolMapper(\"group_membership_mapper\", {\n    claimName: \"groups\",\n    clientScopeId: clientScope.id,\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\ngroup_membership_mapper = keycloak.openid.GroupMembershipProtocolMapper(\"groupMembershipMapper\",\n    claim_name=\"groups\",\n    client_scope_id=client_scope.id,\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var groupMembershipMapper = new Keycloak.OpenId.GroupMembershipProtocolMapper(\"groupMembershipMapper\", new Keycloak.OpenId.GroupMembershipProtocolMapperArgs\n        {\n            ClaimName = \"groups\",\n            ClientScopeId = clientScope.Id,\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewGroupMembershipProtocolMapper(ctx, \"groupMembershipMapper\", \u0026openid.GroupMembershipProtocolMapperArgs{\n\t\t\tClaimName:     pulumi.String(\"groups\"),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tRealmId:       realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `claim_name` - (Required) The name of the claim to insert into a token.\n- `full_path` - (Optional) Indicates whether the full path of the group including its parents will be used. Defaults to `true`.\n- `add_to_id_token` - (Optional) Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n- `add_to_access_token` - (Optional) Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n- `add_to_userinfo` - (Optional) Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean"
                },
                "addToIdToken": {
                    "type": "boolean"
                },
                "addToUserinfo": {
                    "type": "boolean"
                },
                "claimName": {
                    "type": "string"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "fullPath": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean"
                },
                "addToIdToken": {
                    "type": "boolean"
                },
                "addToUserinfo": {
                    "type": "boolean"
                },
                "claimName": {
                    "type": "string"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "fullPath": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupMembershipProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean"
                    },
                    "addToIdToken": {
                        "type": "boolean"
                    },
                    "addToUserinfo": {
                        "type": "boolean"
                    },
                    "claimName": {
                        "type": "string"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                    },
                    "fullPath": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-friendly name that will appear in the Keycloak console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id where the associated client or client scope exists.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/hardcodedClaimProtocolMapper:HardcodedClaimProtocolMapper": {
            "description": "## # keycloak.openid.HardcodedClaimProtocolMapper\n\nAllows for creating and managing hardcoded claim protocol mappers within\nKeycloak.\n\nHardcoded claim protocol mappers allow you to define a claim with a hardcoded\nvalue. Protocol mappers can be defined for a single client, or they can\nbe defined for a client scope which can be shared between multiple different\nclients.\n\n### Example Usage (Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    accessType: \"CONFIDENTIAL\",\n    clientId: \"test-client\",\n    enabled: true,\n    realmId: realm.id,\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst hardcodedClaimMapper = new keycloak.openid.HardcodedClaimProtocolMapper(\"hardcoded_claim_mapper\", {\n    claimName: \"foo\",\n    claimValue: \"bar\",\n    clientId: openidClient.id,\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    access_type=\"CONFIDENTIAL\",\n    client_id=\"test-client\",\n    enabled=True,\n    realm_id=realm.id,\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nhardcoded_claim_mapper = keycloak.openid.HardcodedClaimProtocolMapper(\"hardcodedClaimMapper\",\n    claim_name=\"foo\",\n    claim_value=\"bar\",\n    client_id=openid_client.id,\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            AccessType = \"CONFIDENTIAL\",\n            ClientId = \"test-client\",\n            Enabled = true,\n            RealmId = realm.Id,\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var hardcodedClaimMapper = new Keycloak.OpenId.HardcodedClaimProtocolMapper(\"hardcodedClaimMapper\", new Keycloak.OpenId.HardcodedClaimProtocolMapperArgs\n        {\n            ClaimName = \"foo\",\n            ClaimValue = \"bar\",\n            ClientId = openidClient.Id,\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tRealmId:    realm.ID(),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewHardcodedClaimProtocolMapper(ctx, \"hardcodedClaimMapper\", \u0026openid.HardcodedClaimProtocolMapperArgs{\n\t\t\tClaimName:  pulumi.String(\"foo\"),\n\t\t\tClaimValue: pulumi.String(\"bar\"),\n\t\t\tClientId:   openidClient.ID(),\n\t\t\tRealmId:    realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Example Usage (Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n});\nconst hardcodedClaimMapper = new keycloak.openid.HardcodedClaimProtocolMapper(\"hardcoded_claim_mapper\", {\n    claimName: \"foo\",\n    claimValue: \"bar\",\n    clientScopeId: clientScope.id,\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nhardcoded_claim_mapper = keycloak.openid.HardcodedClaimProtocolMapper(\"hardcodedClaimMapper\",\n    claim_name=\"foo\",\n    claim_value=\"bar\",\n    client_scope_id=client_scope.id,\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var hardcodedClaimMapper = new Keycloak.OpenId.HardcodedClaimProtocolMapper(\"hardcodedClaimMapper\", new Keycloak.OpenId.HardcodedClaimProtocolMapperArgs\n        {\n            ClaimName = \"foo\",\n            ClaimValue = \"bar\",\n            ClientScopeId = clientScope.Id,\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewHardcodedClaimProtocolMapper(ctx, \"hardcodedClaimMapper\", \u0026openid.HardcodedClaimProtocolMapperArgs{\n\t\t\tClaimName:     pulumi.String(\"foo\"),\n\t\t\tClaimValue:    pulumi.String(\"bar\"),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tRealmId:       realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `claim_name` - (Required) The name of the claim to insert into a token.\n- `claim_value` - (Required) The hardcoded value of the claim.\n- `claim_value_type` - (Optional) The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n- `add_to_id_token` - (Optional) Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n- `add_to_access_token` - (Optional) Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n- `add_to_userinfo` - (Optional) Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the id token.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should appear in the userinfo response body.\n"
                },
                "claimName": {
                    "type": "string"
                },
                "claimValue": {
                    "type": "string"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "Claim type used when serializing tokens.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                }
            },
            "required": [
                "claimName",
                "claimValue",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the id token.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should appear in the userinfo response body.\n"
                },
                "claimName": {
                    "type": "string"
                },
                "claimValue": {
                    "type": "string"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "Claim type used when serializing tokens.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "claimValue",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedClaimProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be a claim in the access token.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be a claim in the id token.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should appear in the userinfo response body.\n"
                    },
                    "claimName": {
                        "type": "string"
                    },
                    "claimValue": {
                        "type": "string"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "Claim type used when serializing tokens.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-friendly name that will appear in the Keycloak console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id where the associated client or client scope exists.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/hardcodedRoleProtocolMapper:HardcodedRoleProtocolMapper": {
            "description": "## # keycloak.openid.HardcodedRoleProtocolMapper\n\nAllows for creating and managing hardcoded role protocol mappers within\nKeycloak.\n\nHardcoded role protocol mappers allow you to specify a single role to\nalways map to an access token for a client. Protocol mappers can be\ndefined for a single client, or they can be defined for a client scope\nwhich can be shared between multiple different clients.\n\n### Example Usage (Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst role = new keycloak.Role(\"role\", {\n    realmId: realm.id,\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    accessType: \"CONFIDENTIAL\",\n    clientId: \"test-client\",\n    enabled: true,\n    realmId: realm.id,\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst hardcodedRoleMapper = new keycloak.openid.HardcodedRoleProtocolMapper(\"hardcoded_role_mapper\", {\n    clientId: openidClient.id,\n    realmId: realm.id,\n    roleId: role.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nrole = keycloak.Role(\"role\", realm_id=realm.id)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    access_type=\"CONFIDENTIAL\",\n    client_id=\"test-client\",\n    enabled=True,\n    realm_id=realm.id,\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nhardcoded_role_mapper = keycloak.openid.HardcodedRoleProtocolMapper(\"hardcodedRoleMapper\",\n    client_id=openid_client.id,\n    realm_id=realm.id,\n    role_id=role.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var role = new Keycloak.Role(\"role\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            AccessType = \"CONFIDENTIAL\",\n            ClientId = \"test-client\",\n            Enabled = true,\n            RealmId = realm.Id,\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var hardcodedRoleMapper = new Keycloak.OpenId.HardcodedRoleProtocolMapper(\"hardcodedRoleMapper\", new Keycloak.OpenId.HardcodedRoleProtocolMapperArgs\n        {\n            ClientId = openidClient.Id,\n            RealmId = realm.Id,\n            RoleId = role.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trole, err := keycloak.NewRole(ctx, \"role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tRealmId:    realm.ID(),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewHardcodedRoleProtocolMapper(ctx, \"hardcodedRoleMapper\", \u0026openid.HardcodedRoleProtocolMapperArgs{\n\t\t\tClientId: openidClient.ID(),\n\t\t\tRealmId:  realm.ID(),\n\t\t\tRoleId:   role.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Example Usage (Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst role = new keycloak.Role(\"role\", {\n    realmId: realm.id,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n});\nconst hardcodedRoleMapper = new keycloak.openid.HardcodedRoleProtocolMapper(\"hardcoded_role_mapper\", {\n    clientScopeId: clientScope.id,\n    realmId: realm.id,\n    roleId: role.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nrole = keycloak.Role(\"role\", realm_id=realm.id)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nhardcoded_role_mapper = keycloak.openid.HardcodedRoleProtocolMapper(\"hardcodedRoleMapper\",\n    client_scope_id=client_scope.id,\n    realm_id=realm.id,\n    role_id=role.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var role = new Keycloak.Role(\"role\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var hardcodedRoleMapper = new Keycloak.OpenId.HardcodedRoleProtocolMapper(\"hardcodedRoleMapper\", new Keycloak.OpenId.HardcodedRoleProtocolMapperArgs\n        {\n            ClientScopeId = clientScope.Id,\n            RealmId = realm.Id,\n            RoleId = role.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trole, err := keycloak.NewRole(ctx, \"role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewHardcodedRoleProtocolMapper(ctx, \"hardcodedRoleMapper\", \u0026openid.HardcodedRoleProtocolMapperArgs{\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tRealmId:       realm.ID(),\n\t\t\tRoleId:        role.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the\n  GUI.\n- `role_id` - (Required) The ID of the role to map to an access token.\n",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                },
                "roleId": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId",
                "roleId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                },
                "roleId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId",
                "roleId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedRoleProtocolMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-friendly name that will appear in the Keycloak console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id where the associated client or client scope exists.\n"
                    },
                    "roleId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/userAttributeProtocolMapper:UserAttributeProtocolMapper": {
            "description": "## # keycloak.openid.UserAttributeProtocolMapper\n\nAllows for creating and managing user attribute protocol mappers within\nKeycloak.\n\nUser attribute protocol mappers allow you to map custom attributes defined\nfor a user within Keycloak to a claim in a token. Protocol mappers can be\ndefined for a single client, or they can be defined for a client scope which\ncan be shared between multiple different clients.\n\n### Example Usage (Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    accessType: \"CONFIDENTIAL\",\n    clientId: \"test-client\",\n    enabled: true,\n    realmId: realm.id,\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst userAttributeMapper = new keycloak.openid.UserAttributeProtocolMapper(\"user_attribute_mapper\", {\n    claimName: \"bar\",\n    clientId: openidClient.id,\n    realmId: realm.id,\n    userAttribute: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    access_type=\"CONFIDENTIAL\",\n    client_id=\"test-client\",\n    enabled=True,\n    realm_id=realm.id,\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nuser_attribute_mapper = keycloak.openid.UserAttributeProtocolMapper(\"userAttributeMapper\",\n    claim_name=\"bar\",\n    client_id=openid_client.id,\n    realm_id=realm.id,\n    user_attribute=\"foo\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            AccessType = \"CONFIDENTIAL\",\n            ClientId = \"test-client\",\n            Enabled = true,\n            RealmId = realm.Id,\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var userAttributeMapper = new Keycloak.OpenId.UserAttributeProtocolMapper(\"userAttributeMapper\", new Keycloak.OpenId.UserAttributeProtocolMapperArgs\n        {\n            ClaimName = \"bar\",\n            ClientId = openidClient.Id,\n            RealmId = realm.Id,\n            UserAttribute = \"foo\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tRealmId:    realm.ID(),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserAttributeProtocolMapper(ctx, \"userAttributeMapper\", \u0026openid.UserAttributeProtocolMapperArgs{\n\t\t\tClaimName:     pulumi.String(\"bar\"),\n\t\t\tClientId:      openidClient.ID(),\n\t\t\tRealmId:       realm.ID(),\n\t\t\tUserAttribute: pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Example Usage (Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n});\nconst userAttributeMapper = new keycloak.openid.UserAttributeProtocolMapper(\"user_attribute_mapper\", {\n    claimName: \"bar\",\n    clientScopeId: clientScope.id,\n    realmId: realm.id,\n    userAttribute: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nuser_attribute_mapper = keycloak.openid.UserAttributeProtocolMapper(\"userAttributeMapper\",\n    claim_name=\"bar\",\n    client_scope_id=client_scope.id,\n    realm_id=realm.id,\n    user_attribute=\"foo\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var userAttributeMapper = new Keycloak.OpenId.UserAttributeProtocolMapper(\"userAttributeMapper\", new Keycloak.OpenId.UserAttributeProtocolMapperArgs\n        {\n            ClaimName = \"bar\",\n            ClientScopeId = clientScope.Id,\n            RealmId = realm.Id,\n            UserAttribute = \"foo\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserAttributeProtocolMapper(ctx, \"userAttributeMapper\", \u0026openid.UserAttributeProtocolMapperArgs{\n\t\t\tClaimName:     pulumi.String(\"bar\"),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tRealmId:       realm.ID(),\n\t\t\tUserAttribute: pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `user_attribute` - (Required) The custom user attribute to map a claim for.\n- `claim_name` - (Required) The name of the claim to insert into a token.\n- `claim_value_type` - (Optional) The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n- `multivalued` - (Optional) Indicates whether this attribute is a single value or an array of values. Defaults to `false`.\n- `add_to_id_token` - (Optional) Indicates if the attribute should be added as a claim to the id token. Defaults to `true`.\n- `add_to_access_token` - (Optional) Indicates if the attribute should be added as a claim to the access token. Defaults to `true`.\n- `add_to_userinfo` - (Optional) Indicates if the attribute should be added as a claim to the UserInfo response body. Defaults to `true`.\n- `aggregate_attributes`- (Optional) Indicates whether this attribute is a single value or an array of values. Defaults to `false`.",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the id token.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should appear in the userinfo response body.\n"
                },
                "aggregateAttributes": {
                    "type": "boolean",
                    "description": "Indicates if attribute values should be aggregated within the group attributes\n"
                },
                "claimName": {
                    "type": "string"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "Claim type used when serializing tokens.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates whether this attribute is a single value or an array of values.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                },
                "userAttribute": {
                    "type": "string"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId",
                "userAttribute"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the id token.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should appear in the userinfo response body.\n"
                },
                "aggregateAttributes": {
                    "type": "boolean",
                    "description": "Indicates if attribute values should be aggregated within the group attributes\n"
                },
                "claimName": {
                    "type": "string"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "Claim type used when serializing tokens.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates whether this attribute is a single value or an array of values.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                },
                "userAttribute": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId",
                "userAttribute"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserAttributeProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be a claim in the access token.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be a claim in the id token.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should appear in the userinfo response body.\n"
                    },
                    "aggregateAttributes": {
                        "type": "boolean",
                        "description": "Indicates if attribute values should be aggregated within the group attributes\n"
                    },
                    "claimName": {
                        "type": "string"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "Claim type used when serializing tokens.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                    },
                    "multivalued": {
                        "type": "boolean",
                        "description": "Indicates whether this attribute is a single value or an array of values.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-friendly name that will appear in the Keycloak console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id where the associated client or client scope exists.\n"
                    },
                    "userAttribute": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/userClientRoleProtocolMapper:UserClientRoleProtocolMapper": {
            "description": "## # keycloak.openid.UserClientRoleProtocolMapper\n\nAllows for creating and managing user client role protocol mappers within\nKeycloak.\n\nUser client role protocol mappers allow you to define a claim containing the list of a client roles.\nProtocol mappers can be defined for a single client, or they can\nbe defined for a client scope which can be shared between multiple different\nclients.\n\n### Example Usage (Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    accessType: \"CONFIDENTIAL\",\n    clientId: \"test-client\",\n    enabled: true,\n    realmId: realm.id,\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst userClientRoleMapper = new keycloak.openid.UserClientRoleProtocolMapper(\"user_client_role_mapper\", {\n    claimName: \"foo\",\n    clientId: openidClient.id,\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    access_type=\"CONFIDENTIAL\",\n    client_id=\"test-client\",\n    enabled=True,\n    realm_id=realm.id,\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nuser_client_role_mapper = keycloak.openid.UserClientRoleProtocolMapper(\"userClientRoleMapper\",\n    claim_name=\"foo\",\n    client_id=openid_client.id,\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            AccessType = \"CONFIDENTIAL\",\n            ClientId = \"test-client\",\n            Enabled = true,\n            RealmId = realm.Id,\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var userClientRoleMapper = new Keycloak.OpenId.UserClientRoleProtocolMapper(\"userClientRoleMapper\", new Keycloak.OpenId.UserClientRoleProtocolMapperArgs\n        {\n            ClaimName = \"foo\",\n            ClientId = openidClient.Id,\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tRealmId:    realm.ID(),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserClientRoleProtocolMapper(ctx, \"userClientRoleMapper\", \u0026openid.UserClientRoleProtocolMapperArgs{\n\t\t\tClaimName: pulumi.String(\"foo\"),\n\t\t\tClientId:  openidClient.ID(),\n\t\t\tRealmId:   realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Example Usage (Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n});\nconst userClientRoleMapper = new keycloak.openid.UserClientRoleProtocolMapper(\"user_client_role_mapper\", {\n    claimName: \"foo\",\n    clientScopeId: clientScope.id,\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nuser_client_role_mapper = keycloak.openid.UserClientRoleProtocolMapper(\"userClientRoleMapper\",\n    claim_name=\"foo\",\n    client_scope_id=client_scope.id,\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var userClientRoleMapper = new Keycloak.OpenId.UserClientRoleProtocolMapper(\"userClientRoleMapper\", new Keycloak.OpenId.UserClientRoleProtocolMapperArgs\n        {\n            ClaimName = \"foo\",\n            ClientScopeId = clientScope.Id,\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserClientRoleProtocolMapper(ctx, \"userClientRoleMapper\", \u0026openid.UserClientRoleProtocolMapperArgs{\n\t\t\tClaimName:     pulumi.String(\"foo\"),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tRealmId:       realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `claim_name` - (Required) The name of the claim to insert into a token.\n- `claim_value_type` - (Optional) The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n- `multivalued` - (Optional) Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n- `client_id_for_role_mappings` - (Optional) The Client ID for role mappings. Just client roles of this client will be added to the token. If this is unset, client roles of all clients will be added to the token. \n- `client_role_prefix` - (Optional) A prefix for each Client Role.\n- `add_to_id_token` - (Optional) Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n- `add_to_access_token` - (Optional) Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n- `add_to_userinfo` - (Optional) Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the id token.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should appear in the userinfo response body.\n"
                },
                "claimName": {
                    "type": "string"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "Claim type used when serializing tokens.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientIdForRoleMappings": {
                    "type": "string",
                    "description": "Client ID for role mappings.\n"
                },
                "clientRolePrefix": {
                    "type": "string",
                    "description": "Prefix that will be added to each client role.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates whether this attribute is a single value or an array of values.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the id token.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should appear in the userinfo response body.\n"
                },
                "claimName": {
                    "type": "string"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "Claim type used when serializing tokens.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientIdForRoleMappings": {
                    "type": "string",
                    "description": "Client ID for role mappings.\n"
                },
                "clientRolePrefix": {
                    "type": "string",
                    "description": "Prefix that will be added to each client role.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates whether this attribute is a single value or an array of values.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserClientRoleProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be a claim in the access token.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be a claim in the id token.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should appear in the userinfo response body.\n"
                    },
                    "claimName": {
                        "type": "string"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "Claim type used when serializing tokens.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                    },
                    "clientIdForRoleMappings": {
                        "type": "string",
                        "description": "Client ID for role mappings.\n"
                    },
                    "clientRolePrefix": {
                        "type": "string",
                        "description": "Prefix that will be added to each client role.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                    },
                    "multivalued": {
                        "type": "boolean",
                        "description": "Indicates whether this attribute is a single value or an array of values.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-friendly name that will appear in the Keycloak console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id where the associated client or client scope exists.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/userPropertyProtocolMapper:UserPropertyProtocolMapper": {
            "description": "## # keycloak.openid.UserPropertyProtocolMapper\n\nAllows for creating and managing user property protocol mappers within\nKeycloak.\n\nUser property protocol mappers allow you to map built in properties defined\non the Keycloak user interface to a claim in a token. Protocol mappers can be\ndefined for a single client, or they can be defined for a client scope which\ncan be shared between multiple different clients.\n\n### Example Usage (Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    accessType: \"CONFIDENTIAL\",\n    clientId: \"test-client\",\n    enabled: true,\n    realmId: realm.id,\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst userPropertyMapper = new keycloak.openid.UserPropertyProtocolMapper(\"user_property_mapper\", {\n    claimName: \"email\",\n    clientId: openidClient.id,\n    realmId: realm.id,\n    userProperty: \"email\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    access_type=\"CONFIDENTIAL\",\n    client_id=\"test-client\",\n    enabled=True,\n    realm_id=realm.id,\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nuser_property_mapper = keycloak.openid.UserPropertyProtocolMapper(\"userPropertyMapper\",\n    claim_name=\"email\",\n    client_id=openid_client.id,\n    realm_id=realm.id,\n    user_property=\"email\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            AccessType = \"CONFIDENTIAL\",\n            ClientId = \"test-client\",\n            Enabled = true,\n            RealmId = realm.Id,\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var userPropertyMapper = new Keycloak.OpenId.UserPropertyProtocolMapper(\"userPropertyMapper\", new Keycloak.OpenId.UserPropertyProtocolMapperArgs\n        {\n            ClaimName = \"email\",\n            ClientId = openidClient.Id,\n            RealmId = realm.Id,\n            UserProperty = \"email\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tRealmId:    realm.ID(),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserPropertyProtocolMapper(ctx, \"userPropertyMapper\", \u0026openid.UserPropertyProtocolMapperArgs{\n\t\t\tClaimName:    pulumi.String(\"email\"),\n\t\t\tClientId:     openidClient.ID(),\n\t\t\tRealmId:      realm.ID(),\n\t\t\tUserProperty: pulumi.String(\"email\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Example Usage (Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n});\nconst userPropertyMapper = new keycloak.openid.UserPropertyProtocolMapper(\"user_property_mapper\", {\n    claimName: \"email\",\n    clientScopeId: clientScope.id,\n    realmId: realm.id,\n    userProperty: \"email\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nuser_property_mapper = keycloak.openid.UserPropertyProtocolMapper(\"userPropertyMapper\",\n    claim_name=\"email\",\n    client_scope_id=client_scope.id,\n    realm_id=realm.id,\n    user_property=\"email\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var userPropertyMapper = new Keycloak.OpenId.UserPropertyProtocolMapper(\"userPropertyMapper\", new Keycloak.OpenId.UserPropertyProtocolMapperArgs\n        {\n            ClaimName = \"email\",\n            ClientScopeId = clientScope.Id,\n            RealmId = realm.Id,\n            UserProperty = \"email\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserPropertyProtocolMapper(ctx, \"userPropertyMapper\", \u0026openid.UserPropertyProtocolMapperArgs{\n\t\t\tClaimName:     pulumi.String(\"email\"),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tRealmId:       realm.ID(),\n\t\t\tUserProperty:  pulumi.String(\"email\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `user_property` - (Required) The built in user property (such as email) to map a claim for.\n- `claim_name` - (Required) The name of the claim to insert into a token.\n- `claim_value_type` - (Optional) The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n- `add_to_id_token` - (Optional) Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n- `add_to_access_token` - (Optional) Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n- `add_to_userinfo` - (Optional) Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be a claim in the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be a claim in the id token.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should appear in the userinfo response body.\n"
                },
                "claimName": {
                    "type": "string"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "Claim type used when serializing tokens.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                },
                "userProperty": {
                    "type": "string"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId",
                "userProperty"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be a claim in the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be a claim in the id token.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should appear in the userinfo response body.\n"
                },
                "claimName": {
                    "type": "string"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "Claim type used when serializing tokens.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                },
                "userProperty": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId",
                "userProperty"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserPropertyProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be a claim in the access token.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be a claim in the id token.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the property should appear in the userinfo response body.\n"
                    },
                    "claimName": {
                        "type": "string"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "Claim type used when serializing tokens.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-friendly name that will appear in the Keycloak console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id where the associated client or client scope exists.\n"
                    },
                    "userProperty": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/userRealmRoleProtocolMapper:UserRealmRoleProtocolMapper": {
            "description": "## # keycloak.openid.UserRealmRoleProtocolMapper\n\nAllows for creating and managing user realm role protocol mappers within\nKeycloak.\n\nUser realm role protocol mappers allow you to define a claim containing the list of the realm roles.\nProtocol mappers can be defined for a single client, or they can\nbe defined for a client scope which can be shared between multiple different\nclients.\n\n### Example Usage (Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    accessType: \"CONFIDENTIAL\",\n    clientId: \"test-client\",\n    enabled: true,\n    realmId: realm.id,\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst userRealmRoleMapper = new keycloak.openid.UserRealmRoleProtocolMapper(\"user_realm_role_mapper\", {\n    claimName: \"foo\",\n    clientId: openidClient.id,\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    access_type=\"CONFIDENTIAL\",\n    client_id=\"test-client\",\n    enabled=True,\n    realm_id=realm.id,\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nuser_realm_role_mapper = keycloak.openid.UserRealmRoleProtocolMapper(\"userRealmRoleMapper\",\n    claim_name=\"foo\",\n    client_id=openid_client.id,\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            AccessType = \"CONFIDENTIAL\",\n            ClientId = \"test-client\",\n            Enabled = true,\n            RealmId = realm.Id,\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var userRealmRoleMapper = new Keycloak.OpenId.UserRealmRoleProtocolMapper(\"userRealmRoleMapper\", new Keycloak.OpenId.UserRealmRoleProtocolMapperArgs\n        {\n            ClaimName = \"foo\",\n            ClientId = openidClient.Id,\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tRealmId:    realm.ID(),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserRealmRoleProtocolMapper(ctx, \"userRealmRoleMapper\", \u0026openid.UserRealmRoleProtocolMapperArgs{\n\t\t\tClaimName: pulumi.String(\"foo\"),\n\t\t\tClientId:  openidClient.ID(),\n\t\t\tRealmId:   realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Example Usage (Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n});\nconst userRealmRoleMapper = new keycloak.openid.UserRealmRoleProtocolMapper(\"user_realm_role_mapper\", {\n    claimName: \"foo\",\n    clientScopeId: clientScope.id,\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nuser_realm_role_mapper = keycloak.openid.UserRealmRoleProtocolMapper(\"userRealmRoleMapper\",\n    claim_name=\"foo\",\n    client_scope_id=client_scope.id,\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var userRealmRoleMapper = new Keycloak.OpenId.UserRealmRoleProtocolMapper(\"userRealmRoleMapper\", new Keycloak.OpenId.UserRealmRoleProtocolMapperArgs\n        {\n            ClaimName = \"foo\",\n            ClientScopeId = clientScope.Id,\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserRealmRoleProtocolMapper(ctx, \"userRealmRoleMapper\", \u0026openid.UserRealmRoleProtocolMapperArgs{\n\t\t\tClaimName:     pulumi.String(\"foo\"),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tRealmId:       realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `claim_name` - (Required) The name of the claim to insert into a token.\n- `claim_value_type` - (Optional) The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n- `multivalued` - (Optional) Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n- `realm_role_prefix` - (Optional) A prefix for each Realm Role.\n- `add_to_id_token` - (Optional) Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n- `add_to_access_token` - (Optional) Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n- `add_to_userinfo` - (Optional) Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the id token.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should appear in the userinfo response body.\n"
                },
                "claimName": {
                    "type": "string"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "Claim type used when serializing tokens.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates whether this attribute is a single value or an array of values.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                },
                "realmRolePrefix": {
                    "type": "string",
                    "description": "Prefix that will be added to each realm role.\n"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the id token.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should appear in the userinfo response body.\n"
                },
                "claimName": {
                    "type": "string"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "Claim type used when serializing tokens.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates whether this attribute is a single value or an array of values.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                },
                "realmRolePrefix": {
                    "type": "string",
                    "description": "Prefix that will be added to each realm role.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserRealmRoleProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be a claim in the access token.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be a claim in the id token.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should appear in the userinfo response body.\n"
                    },
                    "claimName": {
                        "type": "string"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "Claim type used when serializing tokens.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                    },
                    "multivalued": {
                        "type": "boolean",
                        "description": "Indicates whether this attribute is a single value or an array of values.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-friendly name that will appear in the Keycloak console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id where the associated client or client scope exists.\n"
                    },
                    "realmRolePrefix": {
                        "type": "string",
                        "description": "Prefix that will be added to each realm role.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/userSessionNoteProtocolMapper:UserSessionNoteProtocolMapper": {
            "description": "## # keycloak.openid.UserSessionNoteProtocolMapper\n\nAllows for creating and managing user session note protocol mappers within\nKeycloak.\n\nUser session note protocol mappers map a custom user session note to a token claim.\nProtocol mappers can be defined for a single client, or they can\nbe defined for a client scope which can be shared between multiple different\nclients.\n\n### Example Usage (Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    accessType: \"CONFIDENTIAL\",\n    clientId: \"test-client\",\n    enabled: true,\n    realmId: realm.id,\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst userSessionNoteClient = new keycloak.openid.UserSessionNoteProtocolMapper(\"user_session_note_client\", {\n    addToAccessToken: false,\n    addToIdToken: true,\n    claimName: \"foo\",\n    claimValueType: \"String\",\n    clientId: openidClient.id,\n    realmId: realm.id,\n    sessionNoteLabel: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    access_type=\"CONFIDENTIAL\",\n    client_id=\"test-client\",\n    enabled=True,\n    realm_id=realm.id,\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nuser_session_note_client = keycloak.openid.UserSessionNoteProtocolMapper(\"userSessionNoteClient\",\n    add_to_access_token=False,\n    add_to_id_token=True,\n    claim_name=\"foo\",\n    claim_value_type=\"String\",\n    client_id=openid_client.id,\n    realm_id=realm.id,\n    session_note_label=\"bar\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            AccessType = \"CONFIDENTIAL\",\n            ClientId = \"test-client\",\n            Enabled = true,\n            RealmId = realm.Id,\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var userSessionNoteClient = new Keycloak.OpenId.UserSessionNoteProtocolMapper(\"userSessionNoteClient\", new Keycloak.OpenId.UserSessionNoteProtocolMapperArgs\n        {\n            AddToAccessToken = false,\n            AddToIdToken = true,\n            ClaimName = \"foo\",\n            ClaimValueType = \"String\",\n            ClientId = openidClient.Id,\n            RealmId = realm.Id,\n            SessionNoteLabel = \"bar\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tRealmId:    realm.ID(),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserSessionNoteProtocolMapper(ctx, \"userSessionNoteClient\", \u0026openid.UserSessionNoteProtocolMapperArgs{\n\t\t\tAddToAccessToken: pulumi.Bool(false),\n\t\t\tAddToIdToken:     pulumi.Bool(true),\n\t\t\tClaimName:        pulumi.String(\"foo\"),\n\t\t\tClaimValueType:   pulumi.String(\"String\"),\n\t\t\tClientId:         openidClient.ID(),\n\t\t\tRealmId:          realm.ID(),\n\t\t\tSessionNoteLabel: pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Example Usage (Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n});\nconst userSessionNoteClientScope = new keycloak.openid.UserSessionNoteProtocolMapper(\"user_session_note_client_scope\", {\n    addToAccessToken: false,\n    addToIdToken: true,\n    claimName: \"foo\",\n    claimValueType: \"String\",\n    clientScopeId: clientScope.id,\n    realmId: realm.id,\n    sessionNoteLabel: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nuser_session_note_client_scope = keycloak.openid.UserSessionNoteProtocolMapper(\"userSessionNoteClientScope\",\n    add_to_access_token=False,\n    add_to_id_token=True,\n    claim_name=\"foo\",\n    claim_value_type=\"String\",\n    client_scope_id=client_scope.id,\n    realm_id=realm.id,\n    session_note_label=\"bar\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var userSessionNoteClientScope = new Keycloak.OpenId.UserSessionNoteProtocolMapper(\"userSessionNoteClientScope\", new Keycloak.OpenId.UserSessionNoteProtocolMapperArgs\n        {\n            AddToAccessToken = false,\n            AddToIdToken = true,\n            ClaimName = \"foo\",\n            ClaimValueType = \"String\",\n            ClientScopeId = clientScope.Id,\n            RealmId = realm.Id,\n            SessionNoteLabel = \"bar\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserSessionNoteProtocolMapper(ctx, \"userSessionNoteClientScope\", \u0026openid.UserSessionNoteProtocolMapperArgs{\n\t\t\tAddToAccessToken: pulumi.Bool(false),\n\t\t\tAddToIdToken:     pulumi.Bool(true),\n\t\t\tClaimName:        pulumi.String(\"foo\"),\n\t\t\tClaimValueType:   pulumi.String(\"String\"),\n\t\t\tClientScopeId:    clientScope.ID(),\n\t\t\tRealmId:          realm.ID(),\n\t\t\tSessionNoteLabel: pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `claim_name` - (Required) The name of the claim to insert into a token.\n- `claim_value_type` - (Optional) The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n- `session_note_label` - (Optional) String value being the name of stored user session note within the UserSessionModel.note map.\n- `add_to_id_token` - (Optional) Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n- `add_to_access_token` - (Optional) Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the id token.\n"
                },
                "claimName": {
                    "type": "string"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "Claim type used when serializing tokens.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                },
                "sessionNoteLabel": {
                    "type": "string",
                    "description": "String value being the name of stored user session note within the UserSessionModel.note map.\n"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the id token.\n"
                },
                "claimName": {
                    "type": "string"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "Claim type used when serializing tokens.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                },
                "sessionNoteLabel": {
                    "type": "string",
                    "description": "String value being the name of stored user session note within the UserSessionModel.note map.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserSessionNoteProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be a claim in the access token.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be a claim in the id token.\n"
                    },
                    "claimName": {
                        "type": "string"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "Claim type used when serializing tokens.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-friendly name that will appear in the Keycloak console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id where the associated client or client scope exists.\n"
                    },
                    "sessionNoteLabel": {
                        "type": "string",
                        "description": "String value being the name of stored user session note within the UserSessionModel.note map.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/client:Client": {
            "description": "## # keycloak.saml.Client\n\nAllows for creating and managing Keycloak clients that use the SAML protocol.\n\nClients are entities that can use Keycloak for user authentication. Typically,\nclients are applications that redirect users to Keycloak for authentication\nin order to take advantage of Keycloak's user sessions for SSO.\n\n### Example Usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst samlClient = new keycloak.saml.Client(\"saml_client\", {\n    clientId: \"test-saml-client\",\n    includeAuthnStatement: true,\n    realmId: realm.id,\n    signAssertions: true,\n    signDocuments: false,\n    signingCertificate: fs.readFileSync(\"saml-cert.pem\", \"utf-8\"),\n    signingPrivateKey: fs.readFileSync(\"saml-key.pem\", \"utf-8\"),\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nsaml_client = keycloak.saml.Client(\"samlClient\",\n    client_id=\"test-saml-client\",\n    include_authn_statement=True,\n    realm_id=realm.id,\n    sign_assertions=True,\n    sign_documents=False,\n    signing_certificate=(lambda path: open(path).read())(\"saml-cert.pem\"),\n    signing_private_key=(lambda path: open(path).read())(\"saml-key.pem\"))\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var samlClient = new Keycloak.Saml.Client(\"samlClient\", new Keycloak.Saml.ClientArgs\n        {\n            ClientId = \"test-saml-client\",\n            IncludeAuthnStatement = true,\n            RealmId = realm.Id,\n            SignAssertions = true,\n            SignDocuments = false,\n            SigningCertificate = File.ReadAllText(\"saml-cert.pem\"),\n            SigningPrivateKey = File.ReadAllText(\"saml-key.pem\"),\n        });\n    }\n\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this client is attached to.\n- `client_id` - (Required) The unique ID of this client, referenced in the URI during authentication and in issued tokens.\n- `name` - (Optional) The display name of this client in the GUI.\n- `enabled` - (Optional) When false, this client will not be able to initiate a login or obtain access tokens. Defaults to `true`.\n- `description` - (Optional) The description of this client in the GUI.\n- `include_authn_statement` - (Optional) When `true`, an `AuthnStatement` will be included in the SAML response.\n- `sign_documents` - (Optional) When `true`, the SAML document will be signed by Keycloak using the realm's private key.\n- `sign_assertions` - (Optional) When `true`, the SAML assertions will be signed by Keycloak using the realm's private key, and embedded within the SAML XML Auth response.\n- `encrypt_assertions` - (Optional) When `true`, the SAML assertions will be encrypted by Keycloak using the client's public key.\n- `client_signature_required` - (Optional) When `true`, Keycloak will expect that documents originating from a client will be signed using the certificate and/or key configured via `signing_certificate` and `signing_private_key`.\n- `force_post_binding` - (Optional) When `true`, Keycloak will always respond to an authentication request via the SAML POST Binding.\n- `front_channel_logout` - (Optional) When `true`, this client will require a browser redirect in order to perform a logout.\n- `name_id_format` - (Optional) Sets the Name ID format for the subject.\n- `force_name_id_format` - (Optional) Ignore requested NameID subject format and use the one defined in `name_id_format` instead.\n- `signature_algorithm` - (Optional) The signature algorithm used to sign documents. Should be one of \"RSA_SHA1\", \"RSA_SHA256\", \"RSA_SHA512\", or \"DSA_SHA1\".\n- `root_url` - (Optional) When specified, this value is prepended to all relative URLs.\n- `valid_redirect_uris` - (Optional) When specified, Keycloak will use this list to validate given Assertion Consumer URLs specified in the authentication request.\n- `base_url` - (Optional) When specified, this URL will be used whenever Keycloak needs to link to this client.\n- `master_saml_processing_url` - (Optional) When specified, this URL will be used for all SAML requests.\n- `encryption_certificate` - (Optional) If assertions for the client are encrypted, this certificate will be used for encryption.\n- `signing_certificate` - (Optional) If documents or assertions from the client are signed, this certificate will be used to verify the signature.\n- `signing_private_key` - (Optional) If documents or assertions from the client are signed, this private key will be used to verify the signature.\n- `idp_initiated_sso_url_name` - (Optional) URL fragment name to reference client when you want to do IDP Initiated SSO.\n- `idp_initiated_sso_relay_state` - (Optional) Relay state you want to send with SAML request when you want to do IDP Initiated SSO.\n- `assertion_consumer_post_url` - (Optional) SAML POST Binding URL for the client's assertion consumer service (login responses).\n- `assertion_consumer_redirect_url` - (Optional) SAML Redirect Binding URL for the client's assertion consumer service (login responses).\n- `logout_service_post_binding_url` - (Optional) SAML POST Binding URL for the client's single logout service.\n- `logout_service_redirect_binding_url` - (Optional) SAML Redirect Binding URL for the client's single logout service.\n- `full_scope_allowed` - (Optional) - Allow to include all roles mappings in the access token\n",
            "properties": {
                "assertionConsumerPostUrl": {
                    "type": "string"
                },
                "assertionConsumerRedirectUrl": {
                    "type": "string"
                },
                "baseUrl": {
                    "type": "string"
                },
                "clientId": {
                    "type": "string"
                },
                "clientSignatureRequired": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string"
                },
                "enabled": {
                    "type": "boolean"
                },
                "encryptAssertions": {
                    "type": "boolean"
                },
                "encryptionCertificate": {
                    "type": "string"
                },
                "forceNameIdFormat": {
                    "type": "boolean"
                },
                "forcePostBinding": {
                    "type": "boolean"
                },
                "frontChannelLogout": {
                    "type": "boolean"
                },
                "fullScopeAllowed": {
                    "type": "boolean"
                },
                "idpInitiatedSsoRelayState": {
                    "type": "string"
                },
                "idpInitiatedSsoUrlName": {
                    "type": "string"
                },
                "includeAuthnStatement": {
                    "type": "boolean"
                },
                "logoutServicePostBindingUrl": {
                    "type": "string"
                },
                "logoutServiceRedirectBindingUrl": {
                    "type": "string"
                },
                "masterSamlProcessingUrl": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "nameIdFormat": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "rootUrl": {
                    "type": "string"
                },
                "signAssertions": {
                    "type": "boolean"
                },
                "signDocuments": {
                    "type": "boolean"
                },
                "signatureAlgorithm": {
                    "type": "string"
                },
                "signingCertificate": {
                    "type": "string"
                },
                "signingPrivateKey": {
                    "type": "string"
                },
                "validRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "clientId",
                "clientSignatureRequired",
                "encryptAssertions",
                "forceNameIdFormat",
                "forcePostBinding",
                "frontChannelLogout",
                "includeAuthnStatement",
                "name",
                "nameIdFormat",
                "realmId",
                "signAssertions",
                "signDocuments"
            ],
            "inputProperties": {
                "assertionConsumerPostUrl": {
                    "type": "string"
                },
                "assertionConsumerRedirectUrl": {
                    "type": "string"
                },
                "baseUrl": {
                    "type": "string"
                },
                "clientId": {
                    "type": "string"
                },
                "clientSignatureRequired": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string"
                },
                "enabled": {
                    "type": "boolean"
                },
                "encryptAssertions": {
                    "type": "boolean"
                },
                "encryptionCertificate": {
                    "type": "string"
                },
                "forceNameIdFormat": {
                    "type": "boolean"
                },
                "forcePostBinding": {
                    "type": "boolean"
                },
                "frontChannelLogout": {
                    "type": "boolean"
                },
                "fullScopeAllowed": {
                    "type": "boolean"
                },
                "idpInitiatedSsoRelayState": {
                    "type": "string"
                },
                "idpInitiatedSsoUrlName": {
                    "type": "string"
                },
                "includeAuthnStatement": {
                    "type": "boolean"
                },
                "logoutServicePostBindingUrl": {
                    "type": "string"
                },
                "logoutServiceRedirectBindingUrl": {
                    "type": "string"
                },
                "masterSamlProcessingUrl": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "nameIdFormat": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "rootUrl": {
                    "type": "string"
                },
                "signAssertions": {
                    "type": "boolean"
                },
                "signDocuments": {
                    "type": "boolean"
                },
                "signatureAlgorithm": {
                    "type": "string"
                },
                "signingCertificate": {
                    "type": "string"
                },
                "signingPrivateKey": {
                    "type": "string"
                },
                "validRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "requiredInputs": [
                "clientId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Client resources.\n",
                "properties": {
                    "assertionConsumerPostUrl": {
                        "type": "string"
                    },
                    "assertionConsumerRedirectUrl": {
                        "type": "string"
                    },
                    "baseUrl": {
                        "type": "string"
                    },
                    "clientId": {
                        "type": "string"
                    },
                    "clientSignatureRequired": {
                        "type": "boolean"
                    },
                    "description": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "encryptAssertions": {
                        "type": "boolean"
                    },
                    "encryptionCertificate": {
                        "type": "string"
                    },
                    "forceNameIdFormat": {
                        "type": "boolean"
                    },
                    "forcePostBinding": {
                        "type": "boolean"
                    },
                    "frontChannelLogout": {
                        "type": "boolean"
                    },
                    "fullScopeAllowed": {
                        "type": "boolean"
                    },
                    "idpInitiatedSsoRelayState": {
                        "type": "string"
                    },
                    "idpInitiatedSsoUrlName": {
                        "type": "string"
                    },
                    "includeAuthnStatement": {
                        "type": "boolean"
                    },
                    "logoutServicePostBindingUrl": {
                        "type": "string"
                    },
                    "logoutServiceRedirectBindingUrl": {
                        "type": "string"
                    },
                    "masterSamlProcessingUrl": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nameIdFormat": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "rootUrl": {
                        "type": "string"
                    },
                    "signAssertions": {
                        "type": "boolean"
                    },
                    "signDocuments": {
                        "type": "boolean"
                    },
                    "signatureAlgorithm": {
                        "type": "string"
                    },
                    "signingCertificate": {
                        "type": "string"
                    },
                    "signingPrivateKey": {
                        "type": "string"
                    },
                    "validRedirectUris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/clientDefaultScope:ClientDefaultScope": {
            "properties": {
                "clientId": {
                    "type": "string"
                },
                "defaultScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "clientId",
                "defaultScopes",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string"
                },
                "defaultScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "clientId",
                "defaultScopes",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientDefaultScope resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string"
                    },
                    "defaultScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/clientScope:ClientScope": {
            "description": "## # keycloak.saml.ClientScope\n\nAllows for creating and managing Keycloak client scopes that can be attached to\nclients that use the SAML protocol.\n\nClient Scopes can be used to share common protocol and role mappings between multiple\nclients within a realm.\n\n### Example Usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst samlClientScope = new keycloak.saml.ClientScope(\"saml_client_scope\", {\n    description: \"This scope will map a user's group memberships to SAML assertion\",\n    guiOrder: 1,\n    realmId: realm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nsaml_client_scope = keycloak.saml.ClientScope(\"samlClientScope\",\n    description=\"This scope will map a user's group memberships to SAML assertion\",\n    gui_order=1,\n    realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var samlClientScope = new Keycloak.Saml.ClientScope(\"samlClientScope\", new Keycloak.Saml.ClientScopeArgs\n        {\n            Description = \"This scope will map a user's group memberships to SAML assertion\",\n            GuiOrder = 1,\n            RealmId = realm.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = saml.NewClientScope(ctx, \"samlClientScope\", \u0026saml.ClientScopeArgs{\n\t\t\tDescription: pulumi.String(\"This scope will map a user's group memberships to SAML assertion\"),\n\t\t\tGuiOrder:    pulumi.Int(1),\n\t\t\tRealmId:     realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this client scope belongs to.\n- `name` - (Required) The display name of this client scope in the GUI.\n- `description` - (Optional) The description of this client scope in the GUI.\n- `consent_screen_text` - (Optional) When set, a consent screen will be displayed to users\nauthenticating to clients with this scope attached. The consent screen will display the string\nvalue of this attribute.\n- `gui_order` - (Optional) Specify order of the client scope in GUI (such as in Consent page) as integer.\n",
            "properties": {
                "consentScreenText": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "guiOrder": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "consentScreenText": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "guiOrder": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientScope resources.\n",
                "properties": {
                    "consentScreenText": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "guiOrder": {
                        "type": "integer"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/identityProvider:IdentityProvider": {
            "description": "## # keycloak.saml.IdentityProvider\n\nAllows to create and manage SAML Identity Providers within Keycloak.\n\nSAML (Security Assertion Markup Language) identity providers allows to authenticate through a third-party system, using SAML standard.\n\n### Example Usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realmIdentityProvider = new keycloak.saml.IdentityProvider(\"realm_identity_provider\", {\n    alias: \"my-idp\",\n    backchannelSupported: true,\n    forceAuthn: true,\n    postBindingAuthnRequest: true,\n    postBindingLogout: true,\n    postBindingResponse: true,\n    realm: \"my-realm\",\n    singleLogoutServiceUrl: \"https://domain.com/adfs/ls/?wa=wsignout1.0\",\n    singleSignOnServiceUrl: \"https://domain.com/adfs/ls/\",\n    storeToken: false,\n    trustEmail: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm_identity_provider = keycloak.saml.IdentityProvider(\"realmIdentityProvider\",\n    alias=\"my-idp\",\n    backchannel_supported=True,\n    force_authn=True,\n    post_binding_authn_request=True,\n    post_binding_logout=True,\n    post_binding_response=True,\n    realm=\"my-realm\",\n    single_logout_service_url=\"https://domain.com/adfs/ls/?wa=wsignout1.0\",\n    single_sign_on_service_url=\"https://domain.com/adfs/ls/\",\n    store_token=False,\n    trust_email=True)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realmIdentityProvider = new Keycloak.Saml.IdentityProvider(\"realmIdentityProvider\", new Keycloak.Saml.IdentityProviderArgs\n        {\n            Alias = \"my-idp\",\n            BackchannelSupported = true,\n            ForceAuthn = true,\n            PostBindingAuthnRequest = true,\n            PostBindingLogout = true,\n            PostBindingResponse = true,\n            Realm = \"my-realm\",\n            SingleLogoutServiceUrl = \"https://domain.com/adfs/ls/?wa=wsignout1.0\",\n            SingleSignOnServiceUrl = \"https://domain.com/adfs/ls/\",\n            StoreToken = false,\n            TrustEmail = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := saml.NewIdentityProvider(ctx, \"realmIdentityProvider\", \u0026saml.IdentityProviderArgs{\n\t\t\tAlias:                   pulumi.String(\"my-idp\"),\n\t\t\tBackchannelSupported:    pulumi.Bool(true),\n\t\t\tForceAuthn:              pulumi.Bool(true),\n\t\t\tPostBindingAuthnRequest: pulumi.Bool(true),\n\t\t\tPostBindingLogout:       pulumi.Bool(true),\n\t\t\tPostBindingResponse:     pulumi.Bool(true),\n\t\t\tRealm:                   pulumi.String(\"my-realm\"),\n\t\t\tSingleLogoutServiceUrl:  pulumi.String(\"https://domain.com/adfs/ls/?wa=wsignout1.0\"),\n\t\t\tSingleSignOnServiceUrl:  pulumi.String(\"https://domain.com/adfs/ls/\"),\n\t\t\tStoreToken:              pulumi.Bool(false),\n\t\t\tTrustEmail:              pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm` - (Required) The name of the realm. This is unique across Keycloak.\n- `alias` - (Optional) The uniq name of identity provider.\n- `enabled` - (Optional) When false, users and clients will not be able to access this realm. Defaults to `true`.\n- `display_name` - (Optional) The display name for the realm that is shown when logging in to the admin console.\n- `store_token` - (Optional) Enable/disable if tokens must be stored after authenticating users. Defaults to `true`.\n- `add_read_token_role_on_create` - (Optional) Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role. Defaults to `false`.\n- `trust_email` - (Optional) If enabled then email provided by this provider is not verified even if verification is enabled for the realm. Defaults to `false`.\n- `link_only` - (Optional) If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't want to allow login from the provider, but want to integrate with a provider. Defaults to `false`.\n- `hide_on_login_page` - (Optional) If hidden, then login with this provider is possible only if requested explicitly, e.g. using the 'kc_idp_hint' parameter.\n- `first_broker_login_flow_alias` - (Optional) Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that there is not yet existing Keycloak account linked with the authenticated identity provider account. Defaults to `first broker login`.\n- `post_broker_login_flow_alias` - (Optional) Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it. Defaults to empty.\n- `authenticate_by_default` - (Optional) Authenticate users by default. Defaults to `false`.\n\n#### SAML Configuration\n\n- `single_sign_on_service_url` - (Optional) The Url that must be used to send authentication requests (SAML AuthnRequest).\n- `single_logout_service_url` - (Optional) The Url that must be used to send logout requests.\n- `backchannel_supported` - (Optional) Does the external IDP support back-channel logout ?.\n- `name_id_policy_format` - (Optional) Specifies the URI reference corresponding to a name identifier format. Defaults to empty.\n- `post_binding_response` - (Optional) Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used..\n- `post_binding_authn_request` - (Optional) Indicates whether the AuthnRequest must be sent using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\n- `post_binding_logout` - (Optional) Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\n- `want_assertions_signed` - (Optional) Indicates whether this service provider expects a signed Assertion.\n- `want_assertions_encrypted` - (Optional) Indicates whether this service provider expects an encrypted Assertion.\n- `force_authn` - (Optional) Indicates whether the identity provider must authenticate the presenter directly rather than rely on a previous security context.\n- `validate_signature` - (Optional) Enable/disable signature validation of SAML responses.\n- `signing_certificate` - (Optional) Signing Certificate.\n- `signature_algorithm` - (Optional) Signing Algorithm. Defaults to empty.\n- `xml_sign_key_info_key_name_transformer` - (Optional) Sign Key Transformer. Defaults to empty.\n",
            "properties": {
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.\n"
                },
                "alias": {
                    "type": "string",
                    "description": "The alias uniquely identifies an identity provider and it is also used to build the redirect uri.\n"
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Enable/disable authenticate users by default.\n"
                },
                "backchannelSupported": {
                    "type": "boolean",
                    "description": "Does the external IDP support backchannel logout?\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "Friendly name for Identity Providers.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable/disable this identity provider.\n"
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means\nthat there is not yet existing Keycloak account linked with the authenticated identity provider account.\n"
                },
                "forceAuthn": {
                    "type": "boolean",
                    "description": "Require Force Authn.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "Hide On Login Page.\n"
                },
                "internalId": {
                    "type": "string",
                    "description": "Internal Identity Provider Id\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't\nwant to allow login from the provider, but want to integrate with a provider\n"
                },
                "nameIdPolicyFormat": {
                    "type": "string",
                    "description": "Name ID Policy Format.\n"
                },
                "postBindingAuthnRequest": {
                    "type": "boolean",
                    "description": "Post Binding Authn Request.\n"
                },
                "postBindingLogout": {
                    "type": "boolean",
                    "description": "Post Binding Logout.\n"
                },
                "postBindingResponse": {
                    "type": "boolean",
                    "description": "Post Binding Response.\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want\nadditional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if\nyou don't want any additional authenticators to be triggered after login with this identity provider. Also note, that\nauthenticator implementations must assume that user is already set in ClientSession as identity provider already set it.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "signatureAlgorithm": {
                    "type": "string",
                    "description": "Signing Algorithm.\n"
                },
                "signingCertificate": {
                    "type": "string",
                    "description": "Signing Certificate.\n"
                },
                "singleLogoutServiceUrl": {
                    "type": "string",
                    "description": "Logout URL.\n"
                },
                "singleSignOnServiceUrl": {
                    "type": "string",
                    "description": "SSO Logout URL.\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "Enable/disable if tokens must be stored after authenticating users.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "If enabled then email provided by this provider is not verified even if verification is enabled for the realm.\n"
                },
                "validateSignature": {
                    "type": "boolean",
                    "description": "Enable/disable signature validation of SAML responses.\n"
                },
                "wantAssertionsEncrypted": {
                    "type": "boolean",
                    "description": "Want Assertions Encrypted.\n"
                },
                "wantAssertionsSigned": {
                    "type": "boolean",
                    "description": "Want Assertions Signed.\n"
                },
                "xmlSignKeyInfoKeyNameTransformer": {
                    "type": "string",
                    "description": "Sign Key Transformer.\n"
                }
            },
            "required": [
                "alias",
                "internalId",
                "realm",
                "singleSignOnServiceUrl"
            ],
            "inputProperties": {
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.\n"
                },
                "alias": {
                    "type": "string",
                    "description": "The alias uniquely identifies an identity provider and it is also used to build the redirect uri.\n"
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Enable/disable authenticate users by default.\n"
                },
                "backchannelSupported": {
                    "type": "boolean",
                    "description": "Does the external IDP support backchannel logout?\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "Friendly name for Identity Providers.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable/disable this identity provider.\n"
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means\nthat there is not yet existing Keycloak account linked with the authenticated identity provider account.\n"
                },
                "forceAuthn": {
                    "type": "boolean",
                    "description": "Require Force Authn.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "Hide On Login Page.\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't\nwant to allow login from the provider, but want to integrate with a provider\n"
                },
                "nameIdPolicyFormat": {
                    "type": "string",
                    "description": "Name ID Policy Format.\n"
                },
                "postBindingAuthnRequest": {
                    "type": "boolean",
                    "description": "Post Binding Authn Request.\n"
                },
                "postBindingLogout": {
                    "type": "boolean",
                    "description": "Post Binding Logout.\n"
                },
                "postBindingResponse": {
                    "type": "boolean",
                    "description": "Post Binding Response.\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want\nadditional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if\nyou don't want any additional authenticators to be triggered after login with this identity provider. Also note, that\nauthenticator implementations must assume that user is already set in ClientSession as identity provider already set it.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "signatureAlgorithm": {
                    "type": "string",
                    "description": "Signing Algorithm.\n"
                },
                "signingCertificate": {
                    "type": "string",
                    "description": "Signing Certificate.\n"
                },
                "singleLogoutServiceUrl": {
                    "type": "string",
                    "description": "Logout URL.\n"
                },
                "singleSignOnServiceUrl": {
                    "type": "string",
                    "description": "SSO Logout URL.\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "Enable/disable if tokens must be stored after authenticating users.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "If enabled then email provided by this provider is not verified even if verification is enabled for the realm.\n"
                },
                "validateSignature": {
                    "type": "boolean",
                    "description": "Enable/disable signature validation of SAML responses.\n"
                },
                "wantAssertionsEncrypted": {
                    "type": "boolean",
                    "description": "Want Assertions Encrypted.\n"
                },
                "wantAssertionsSigned": {
                    "type": "boolean",
                    "description": "Want Assertions Signed.\n"
                },
                "xmlSignKeyInfoKeyNameTransformer": {
                    "type": "string",
                    "description": "Sign Key Transformer.\n"
                }
            },
            "requiredInputs": [
                "alias",
                "realm",
                "singleSignOnServiceUrl"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IdentityProvider resources.\n",
                "properties": {
                    "addReadTokenRoleOnCreate": {
                        "type": "boolean",
                        "description": "Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.\n"
                    },
                    "alias": {
                        "type": "string",
                        "description": "The alias uniquely identifies an identity provider and it is also used to build the redirect uri.\n"
                    },
                    "authenticateByDefault": {
                        "type": "boolean",
                        "description": "Enable/disable authenticate users by default.\n"
                    },
                    "backchannelSupported": {
                        "type": "boolean",
                        "description": "Does the external IDP support backchannel logout?\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "Friendly name for Identity Providers.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable/disable this identity provider.\n"
                    },
                    "firstBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means\nthat there is not yet existing Keycloak account linked with the authenticated identity provider account.\n"
                    },
                    "forceAuthn": {
                        "type": "boolean",
                        "description": "Require Force Authn.\n"
                    },
                    "hideOnLoginPage": {
                        "type": "boolean",
                        "description": "Hide On Login Page.\n"
                    },
                    "internalId": {
                        "type": "string",
                        "description": "Internal Identity Provider Id\n"
                    },
                    "linkOnly": {
                        "type": "boolean",
                        "description": "If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't\nwant to allow login from the provider, but want to integrate with a provider\n"
                    },
                    "nameIdPolicyFormat": {
                        "type": "string",
                        "description": "Name ID Policy Format.\n"
                    },
                    "postBindingAuthnRequest": {
                        "type": "boolean",
                        "description": "Post Binding Authn Request.\n"
                    },
                    "postBindingLogout": {
                        "type": "boolean",
                        "description": "Post Binding Logout.\n"
                    },
                    "postBindingResponse": {
                        "type": "boolean",
                        "description": "Post Binding Response.\n"
                    },
                    "postBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want\nadditional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if\nyou don't want any additional authenticators to be triggered after login with this identity provider. Also note, that\nauthenticator implementations must assume that user is already set in ClientSession as identity provider already set it.\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "Realm Name\n"
                    },
                    "signatureAlgorithm": {
                        "type": "string",
                        "description": "Signing Algorithm.\n"
                    },
                    "signingCertificate": {
                        "type": "string",
                        "description": "Signing Certificate.\n"
                    },
                    "singleLogoutServiceUrl": {
                        "type": "string",
                        "description": "Logout URL.\n"
                    },
                    "singleSignOnServiceUrl": {
                        "type": "string",
                        "description": "SSO Logout URL.\n"
                    },
                    "storeToken": {
                        "type": "boolean",
                        "description": "Enable/disable if tokens must be stored after authenticating users.\n"
                    },
                    "trustEmail": {
                        "type": "boolean",
                        "description": "If enabled then email provided by this provider is not verified even if verification is enabled for the realm.\n"
                    },
                    "validateSignature": {
                        "type": "boolean",
                        "description": "Enable/disable signature validation of SAML responses.\n"
                    },
                    "wantAssertionsEncrypted": {
                        "type": "boolean",
                        "description": "Want Assertions Encrypted.\n"
                    },
                    "wantAssertionsSigned": {
                        "type": "boolean",
                        "description": "Want Assertions Signed.\n"
                    },
                    "xmlSignKeyInfoKeyNameTransformer": {
                        "type": "string",
                        "description": "Sign Key Transformer.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/userAttributeProtocolMapper:UserAttributeProtocolMapper": {
            "description": "## # keycloak.saml.UserAttributeProtocolMapper\n\nAllows for creating and managing user attribute protocol mappers for\nSAML clients within Keycloak.\n\nSAML user attribute protocol mappers allow you to map custom attributes defined\nfor a user within Keycloak to an attribute in a SAML assertion. Protocol mappers\ncan be defined for a single client, or they can be defined for a client scope which\ncan be shared between multiple different clients.\n\n### Example Usage (Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst samlClient = new keycloak.saml.Client(\"saml_client\", {\n    clientId: \"test-saml-client\",\n    realmId: keycloak_realm_test.id,\n});\nconst samlUserAttributeMapper = new keycloak.saml.UserAttributeProtocolMapper(\"saml_user_attribute_mapper\", {\n    clientId: samlClient.id,\n    realmId: keycloak_realm_test.id,\n    samlAttributeName: \"displayName\",\n    samlAttributeNameFormat: \"Unspecified\",\n    userAttribute: \"displayName\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nsaml_client = keycloak.saml.Client(\"samlClient\",\n    client_id=\"test-saml-client\",\n    realm_id=keycloak_realm[\"test\"][\"id\"])\nsaml_user_attribute_mapper = keycloak.saml.UserAttributeProtocolMapper(\"samlUserAttributeMapper\",\n    client_id=saml_client.id,\n    realm_id=keycloak_realm[\"test\"][\"id\"],\n    saml_attribute_name=\"displayName\",\n    saml_attribute_name_format=\"Unspecified\",\n    user_attribute=\"displayName\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var samlClient = new Keycloak.Saml.Client(\"samlClient\", new Keycloak.Saml.ClientArgs\n        {\n            ClientId = \"test-saml-client\",\n            RealmId = keycloak_realm.Test.Id,\n        });\n        var samlUserAttributeMapper = new Keycloak.Saml.UserAttributeProtocolMapper(\"samlUserAttributeMapper\", new Keycloak.Saml.UserAttributeProtocolMapperArgs\n        {\n            ClientId = samlClient.Id,\n            RealmId = keycloak_realm.Test.Id,\n            SamlAttributeName = \"displayName\",\n            SamlAttributeNameFormat = \"Unspecified\",\n            UserAttribute = \"displayName\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsamlClient, err := saml.NewClient(ctx, \"samlClient\", \u0026saml.ClientArgs{\n\t\t\tClientId: pulumi.String(\"test-saml-client\"),\n\t\t\tRealmId:  pulumi.Any(keycloak_realm.Test.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = saml.NewUserAttributeProtocolMapper(ctx, \"samlUserAttributeMapper\", \u0026saml.UserAttributeProtocolMapperArgs{\n\t\t\tClientId:                samlClient.ID(),\n\t\t\tRealmId:                 pulumi.Any(keycloak_realm.Test.Id),\n\t\t\tSamlAttributeName:       pulumi.String(\"displayName\"),\n\t\t\tSamlAttributeNameFormat: pulumi.String(\"Unspecified\"),\n\t\t\tUserAttribute:           pulumi.String(\"displayName\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The SAML client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The SAML client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `user_attribute` - (Required) The custom user attribute to map.\n- `friendly_name` - (Optional) An optional human-friendly name for this attribute.\n- `saml_attribute_name` - (Required) The name of the SAML attribute.\n- `saml_attribute_name_format` - (Required) The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n",
            "properties": {
                "clientId": {
                    "type": "string"
                },
                "clientScopeId": {
                    "type": "string"
                },
                "friendlyName": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "samlAttributeName": {
                    "type": "string"
                },
                "samlAttributeNameFormat": {
                    "type": "string"
                },
                "userAttribute": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId",
                "samlAttributeName",
                "samlAttributeNameFormat",
                "userAttribute"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string"
                },
                "clientScopeId": {
                    "type": "string"
                },
                "friendlyName": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "samlAttributeName": {
                    "type": "string"
                },
                "samlAttributeNameFormat": {
                    "type": "string"
                },
                "userAttribute": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId",
                "samlAttributeName",
                "samlAttributeNameFormat",
                "userAttribute"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserAttributeProtocolMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string"
                    },
                    "clientScopeId": {
                        "type": "string"
                    },
                    "friendlyName": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "samlAttributeName": {
                        "type": "string"
                    },
                    "samlAttributeNameFormat": {
                        "type": "string"
                    },
                    "userAttribute": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/userPropertyProtocolMapper:UserPropertyProtocolMapper": {
            "description": "## # keycloak.saml.UserPropertyProtocolMapper\n\nAllows for creating and managing user property protocol mappers for\nSAML clients within Keycloak.\n\nSAML user property protocol mappers allow you to map properties of the Keycloak\nuser model to an attribute in a SAML assertion. Protocol mappers\ncan be defined for a single client, or they can be defined for a client scope which\ncan be shared between multiple different clients.\n\n### Example Usage (Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    enabled: true,\n    realm: \"my-realm\",\n});\nconst samlClient = new keycloak.saml.Client(\"saml_client\", {\n    clientId: \"test-saml-client\",\n    realmId: keycloak_realm_test.id,\n});\nconst samlUserPropertyMapper = new keycloak.saml.UserPropertyProtocolMapper(\"saml_user_property_mapper\", {\n    clientId: samlClient.id,\n    realmId: keycloak_realm_test.id,\n    samlAttributeName: \"email\",\n    samlAttributeNameFormat: \"Unspecified\",\n    userProperty: \"email\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    enabled=True,\n    realm=\"my-realm\")\nsaml_client = keycloak.saml.Client(\"samlClient\",\n    client_id=\"test-saml-client\",\n    realm_id=keycloak_realm[\"test\"][\"id\"])\nsaml_user_property_mapper = keycloak.saml.UserPropertyProtocolMapper(\"samlUserPropertyMapper\",\n    client_id=saml_client.id,\n    realm_id=keycloak_realm[\"test\"][\"id\"],\n    saml_attribute_name=\"email\",\n    saml_attribute_name_format=\"Unspecified\",\n    user_property=\"email\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Enabled = true,\n            Realm = \"my-realm\",\n        });\n        var samlClient = new Keycloak.Saml.Client(\"samlClient\", new Keycloak.Saml.ClientArgs\n        {\n            ClientId = \"test-saml-client\",\n            RealmId = keycloak_realm.Test.Id,\n        });\n        var samlUserPropertyMapper = new Keycloak.Saml.UserPropertyProtocolMapper(\"samlUserPropertyMapper\", new Keycloak.Saml.UserPropertyProtocolMapperArgs\n        {\n            ClientId = samlClient.Id,\n            RealmId = keycloak_realm.Test.Id,\n            SamlAttributeName = \"email\",\n            SamlAttributeNameFormat = \"Unspecified\",\n            UserProperty = \"email\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v2/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsamlClient, err := saml.NewClient(ctx, \"samlClient\", \u0026saml.ClientArgs{\n\t\t\tClientId: pulumi.String(\"test-saml-client\"),\n\t\t\tRealmId:  pulumi.Any(keycloak_realm.Test.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = saml.NewUserPropertyProtocolMapper(ctx, \"samlUserPropertyMapper\", \u0026saml.UserPropertyProtocolMapperArgs{\n\t\t\tClientId:                samlClient.ID(),\n\t\t\tRealmId:                 pulumi.Any(keycloak_realm.Test.Id),\n\t\t\tSamlAttributeName:       pulumi.String(\"email\"),\n\t\t\tSamlAttributeNameFormat: pulumi.String(\"Unspecified\"),\n\t\t\tUserProperty:            pulumi.String(\"email\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The SAML client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The SAML client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `user_property` - (Required) The property of the Keycloak user model to map.\n- `friendly_name` - (Optional) An optional human-friendly name for this attribute.\n- `saml_attribute_name` - (Required) The name of the SAML attribute.\n- `saml_attribute_name_format` - (Required) The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n",
            "properties": {
                "clientId": {
                    "type": "string"
                },
                "clientScopeId": {
                    "type": "string"
                },
                "friendlyName": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "samlAttributeName": {
                    "type": "string"
                },
                "samlAttributeNameFormat": {
                    "type": "string"
                },
                "userProperty": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId",
                "samlAttributeName",
                "samlAttributeNameFormat",
                "userProperty"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string"
                },
                "clientScopeId": {
                    "type": "string"
                },
                "friendlyName": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "samlAttributeName": {
                    "type": "string"
                },
                "samlAttributeNameFormat": {
                    "type": "string"
                },
                "userProperty": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId",
                "samlAttributeName",
                "samlAttributeNameFormat",
                "userProperty"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserPropertyProtocolMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string"
                    },
                    "clientScopeId": {
                        "type": "string"
                    },
                    "friendlyName": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "samlAttributeName": {
                        "type": "string"
                    },
                    "samlAttributeNameFormat": {
                        "type": "string"
                    },
                    "userProperty": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "keycloak:index/getGroup:getGroup": {
            "inputs": {
                "description": "A collection of arguments for invoking getGroup.\n",
                "properties": {
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGroup.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "realmId",
                    "id"
                ]
            }
        },
        "keycloak:index/getRealm:getRealm": {
            "inputs": {
                "description": "A collection of arguments for invoking getRealm.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "displayNameHtml": {
                        "type": "string"
                    },
                    "internationalizations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:/getRealmInternationalization:getRealmInternationalization"
                        }
                    },
                    "realm": {
                        "type": "string"
                    },
                    "securityDefenses": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:/getRealmSecurityDefense:getRealmSecurityDefense"
                        }
                    },
                    "smtpServers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:/getRealmSmtpServer:getRealmSmtpServer"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "realm"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRealm.\n",
                "properties": {
                    "accessCodeLifespan": {
                        "type": "string"
                    },
                    "accessCodeLifespanLogin": {
                        "type": "string"
                    },
                    "accessCodeLifespanUserAction": {
                        "type": "string"
                    },
                    "accessTokenLifespan": {
                        "type": "string"
                    },
                    "accessTokenLifespanForImplicitFlow": {
                        "type": "string"
                    },
                    "accountTheme": {
                        "type": "string"
                    },
                    "actionTokenGeneratedByAdminLifespan": {
                        "type": "string"
                    },
                    "actionTokenGeneratedByUserLifespan": {
                        "type": "string"
                    },
                    "adminTheme": {
                        "type": "string"
                    },
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "browserFlow": {
                        "type": "string"
                    },
                    "clientAuthenticationFlow": {
                        "type": "string"
                    },
                    "directGrantFlow": {
                        "type": "string"
                    },
                    "displayName": {
                        "type": "string"
                    },
                    "displayNameHtml": {
                        "type": "string"
                    },
                    "dockerAuthenticationFlow": {
                        "type": "string"
                    },
                    "duplicateEmailsAllowed": {
                        "type": "boolean"
                    },
                    "editUsernameAllowed": {
                        "type": "boolean"
                    },
                    "emailTheme": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "internalId": {
                        "type": "string"
                    },
                    "internationalizations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:/getRealmInternationalization:getRealmInternationalization"
                        }
                    },
                    "loginTheme": {
                        "type": "string"
                    },
                    "loginWithEmailAllowed": {
                        "type": "boolean"
                    },
                    "offlineSessionIdleTimeout": {
                        "type": "string"
                    },
                    "offlineSessionMaxLifespan": {
                        "type": "string"
                    },
                    "passwordPolicy": {
                        "type": "string"
                    },
                    "realm": {
                        "type": "string"
                    },
                    "refreshTokenMaxReuse": {
                        "type": "integer"
                    },
                    "registrationAllowed": {
                        "type": "boolean"
                    },
                    "registrationEmailAsUsername": {
                        "type": "boolean"
                    },
                    "registrationFlow": {
                        "type": "string"
                    },
                    "rememberMe": {
                        "type": "boolean"
                    },
                    "resetCredentialsFlow": {
                        "type": "string"
                    },
                    "resetPasswordAllowed": {
                        "type": "boolean"
                    },
                    "securityDefenses": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:/getRealmSecurityDefense:getRealmSecurityDefense"
                        }
                    },
                    "smtpServers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:/getRealmSmtpServer:getRealmSmtpServer"
                        }
                    },
                    "sslRequired": {
                        "type": "string"
                    },
                    "ssoSessionIdleTimeout": {
                        "type": "string"
                    },
                    "ssoSessionMaxLifespan": {
                        "type": "string"
                    },
                    "userManagedAccess": {
                        "type": "boolean"
                    },
                    "verifyEmail": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "accessCodeLifespan",
                    "accessCodeLifespanLogin",
                    "accessCodeLifespanUserAction",
                    "accessTokenLifespan",
                    "accessTokenLifespanForImplicitFlow",
                    "accountTheme",
                    "actionTokenGeneratedByAdminLifespan",
                    "actionTokenGeneratedByUserLifespan",
                    "adminTheme",
                    "attributes",
                    "browserFlow",
                    "clientAuthenticationFlow",
                    "directGrantFlow",
                    "displayName",
                    "dockerAuthenticationFlow",
                    "duplicateEmailsAllowed",
                    "editUsernameAllowed",
                    "emailTheme",
                    "enabled",
                    "internalId",
                    "internationalizations",
                    "loginTheme",
                    "loginWithEmailAllowed",
                    "offlineSessionIdleTimeout",
                    "offlineSessionMaxLifespan",
                    "passwordPolicy",
                    "realm",
                    "refreshTokenMaxReuse",
                    "registrationAllowed",
                    "registrationEmailAsUsername",
                    "registrationFlow",
                    "rememberMe",
                    "resetCredentialsFlow",
                    "resetPasswordAllowed",
                    "securityDefenses",
                    "smtpServers",
                    "sslRequired",
                    "ssoSessionIdleTimeout",
                    "ssoSessionMaxLifespan",
                    "userManagedAccess",
                    "verifyEmail",
                    "id"
                ]
            }
        },
        "keycloak:index/getRealmKeys:getRealmKeys": {
            "inputs": {
                "description": "A collection of arguments for invoking getRealmKeys.\n",
                "properties": {
                    "algorithms": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "statuses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRealmKeys.\n",
                "properties": {
                    "algorithms": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "keys": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:/getRealmKeysKey:getRealmKeysKey"
                        }
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "statuses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "keys",
                    "realmId",
                    "id"
                ]
            }
        },
        "keycloak:index/getRole:getRole": {
            "inputs": {
                "description": "A collection of arguments for invoking getRole.\n",
                "properties": {
                    "clientId": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRole.\n",
                "properties": {
                    "clientId": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "description",
                    "name",
                    "realmId",
                    "id"
                ]
            }
        },
        "keycloak:openid/getClient:getClient": {
            "inputs": {
                "description": "A collection of arguments for invoking getClient.\n",
                "properties": {
                    "clientId": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "clientId",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClient.\n",
                "properties": {
                    "accessType": {
                        "type": "string"
                    },
                    "authenticationFlowBindingOverrides": {
                        "$ref": "#/types/keycloak:openid/getClientAuthenticationFlowBindingOverrides:getClientAuthenticationFlowBindingOverrides"
                    },
                    "authorization": {
                        "$ref": "#/types/keycloak:openid/getClientAuthorization:getClientAuthorization"
                    },
                    "clientId": {
                        "type": "string"
                    },
                    "clientSecret": {
                        "type": "string"
                    },
                    "consentRequired": {
                        "type": "boolean"
                    },
                    "description": {
                        "type": "string"
                    },
                    "directAccessGrantsEnabled": {
                        "type": "boolean"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "fullScopeAllowed": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "implicitFlowEnabled": {
                        "type": "boolean"
                    },
                    "loginTheme": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "rootUrl": {
                        "type": "string"
                    },
                    "serviceAccountUserId": {
                        "type": "string"
                    },
                    "serviceAccountsEnabled": {
                        "type": "boolean"
                    },
                    "standardFlowEnabled": {
                        "type": "boolean"
                    },
                    "validRedirectUris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "webOrigins": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "accessType",
                    "authenticationFlowBindingOverrides",
                    "authorization",
                    "clientId",
                    "clientSecret",
                    "consentRequired",
                    "description",
                    "directAccessGrantsEnabled",
                    "enabled",
                    "fullScopeAllowed",
                    "implicitFlowEnabled",
                    "loginTheme",
                    "name",
                    "realmId",
                    "resourceServerId",
                    "rootUrl",
                    "serviceAccountUserId",
                    "serviceAccountsEnabled",
                    "standardFlowEnabled",
                    "validRedirectUris",
                    "webOrigins",
                    "id"
                ]
            }
        },
        "keycloak:openid/getClientAuthorizationPolicy:getClientAuthorizationPolicy": {
            "inputs": {
                "description": "A collection of arguments for invoking getClientAuthorizationPolicy.\n",
                "properties": {
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "realmId",
                    "resourceServerId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClientAuthorizationPolicy.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "owner": {
                        "type": "string"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "resources": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "decisionStrategy",
                    "name",
                    "owner",
                    "policies",
                    "realmId",
                    "resourceServerId",
                    "resources",
                    "scopes",
                    "type",
                    "id"
                ]
            }
        },
        "keycloak:openid/getClientServiceAccountUser:getClientServiceAccountUser": {
            "inputs": {
                "description": "A collection of arguments for invoking getClientServiceAccountUser.\n",
                "properties": {
                    "clientId": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "clientId",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClientServiceAccountUser.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "clientId": {
                        "type": "string"
                    },
                    "email": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "federatedIdentities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:openid/getClientServiceAccountUserFederatedIdentity:getClientServiceAccountUserFederatedIdentity"
                        }
                    },
                    "firstName": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "lastName": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "username": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "attributes",
                    "clientId",
                    "email",
                    "enabled",
                    "federatedIdentities",
                    "firstName",
                    "lastName",
                    "realmId",
                    "username",
                    "id"
                ]
            }
        },
        "keycloak:saml/getClientInstallationProvider:getClientInstallationProvider": {
            "inputs": {
                "description": "A collection of arguments for invoking getClientInstallationProvider.\n",
                "properties": {
                    "clientId": {
                        "type": "string"
                    },
                    "providerId": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "clientId",
                    "providerId",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClientInstallationProvider.\n",
                "properties": {
                    "clientId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "providerId": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "value": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "clientId",
                    "providerId",
                    "realmId",
                    "value",
                    "id"
                ]
            }
        }
    },
    "language": {
        "csharp": {
            "namespaces": {
                "authentication": "Authentication",
                "index": "index",
                "keycloak": "Keycloak",
                "ldap": "Ldap",
                "oidc": "Oidc",
                "openid": "OpenId",
                "saml": "Saml"
            },
            "packageReferences": {
                "Pulumi": "2.*",
                "System.Collections.Immutable": "1.6.0"
            }
        },
        "nodejs": {
            "dependencies": {
                "@pulumi/pulumi": "^2.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^8.0.25"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating and managing keycloak cloud resources.",
            "packageName": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/mrparkers/terraform-provider-keycloak)\n\u003e distributed under [MIT](https://mit-license.org/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-keycloak` repo](https://github.com/pulumi/pulumi-keycloak/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`mrparkers/terraform-provider-keycloak` repo](https://github.com/mrparkers/terraform-provider-keycloak/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/mrparkers/terraform-provider-keycloak)\n\u003e distributed under [MIT](https://mit-license.org/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-keycloak` repo](https://github.com/pulumi/pulumi-keycloak/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`mrparkers/terraform-provider-keycloak` repo](https://github.com/mrparkers/terraform-provider-keycloak/issues).",
            "requires": {
                "pulumi": "\u003e=2.9.0,\u003c3.0.0"
            },
            "usesIOClasses": true
        }
    }
}